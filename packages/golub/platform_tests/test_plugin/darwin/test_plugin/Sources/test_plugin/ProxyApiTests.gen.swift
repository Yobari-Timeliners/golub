// Copyright 2013 The Flutter Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// Autogenerated from Golub, do not edit directly.
// See also: https://pub.dev/packages/golub

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
public final class ProxyApiTestsError: Error {
  let code: String
  let message: String?
  let details: Sendable?

  public init(code: String, message: String?, details: Sendable?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "ProxyApiTestsError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
  }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let golubError = error as? ProxyApiTestsError {
    return [
      golubError.code,
      golubError.message,
      golubError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func createConnectionError(withChannelName channelName: String) -> ProxyApiTestsError {
  return ProxyApiTestsError(
    code: "channel-error", message: "Unable to establish connection on channel: '\(channelName)'.",
    details: "")
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

/// Handles the callback when an object is deallocated.
protocol ProxyApiTestsGolubInternalFinalizerDelegate: AnyObject {
  /// Invoked when the strong reference of an object is deallocated in an `InstanceManager`.
  func onDeinit(identifier: Int64)
}

// Attaches to an object to receive a callback when the object is deallocated.
internal final class ProxyApiTestsGolubInternalFinalizer {
  internal static let associatedObjectKey = malloc(1)!

  private let identifier: Int64
  // Reference to the delegate is weak because the callback should be ignored if the
  // `InstanceManager` is deallocated.
  internal weak var delegate: ProxyApiTestsGolubInternalFinalizerDelegate?

  private init(identifier: Int64, delegate: ProxyApiTestsGolubInternalFinalizerDelegate) {
    self.identifier = identifier
    self.delegate = delegate
  }

  internal static func attach(
    to instance: AnyObject, identifier: Int64, delegate: ProxyApiTestsGolubInternalFinalizerDelegate
  ) {
    let finalizer = ProxyApiTestsGolubInternalFinalizer(identifier: identifier, delegate: delegate)
    objc_setAssociatedObject(instance, associatedObjectKey, finalizer, .OBJC_ASSOCIATION_RETAIN)
  }

  static func detach(from instance: AnyObject) {
    let finalizer =
      objc_getAssociatedObject(instance, associatedObjectKey)
      as? ProxyApiTestsGolubInternalFinalizer
    if let finalizer = finalizer {
      finalizer.delegate = nil
      objc_setAssociatedObject(instance, associatedObjectKey, nil, .OBJC_ASSOCIATION_ASSIGN)
    }
  }

  deinit {
    delegate?.onDeinit(identifier: identifier)
  }
}

/// Maintains instances used to communicate with the corresponding objects in Dart.
///
/// Objects stored in this container are represented by an object in Dart that is also stored in
/// an InstanceManager with the same identifier.
///
/// When an instance is added with an identifier, either can be used to retrieve the other.
///
/// Added instances are added as a weak reference and a strong reference. When the strong
/// reference is removed and the weak reference is deallocated,`ProxyApiTestsGolubInternalFinalizerDelegate.onDeinit`
/// is called with the instance's identifier. However, if the strong reference is removed and then the identifier is
/// retrieved with the intention to pass the identifier to Dart (e.g. by calling `identifierWithStrongReference`),
/// the strong reference to the instance is re-added. The strong reference will then need to be removed manually
/// again.
///
/// Accessing and inserting to an InstanceManager is thread safe.
final class ProxyApiTestsGolubInstanceManager {
  // Identifiers are locked to a specific range to avoid collisions with objects
  // created simultaneously from Dart.
  // Host uses identifiers >= 2^16 and Dart is expected to use values n where,
  // 0 <= n < 2^16.
  private static let minHostCreatedIdentifier: Int64 = 65536

  private let lockQueue = DispatchQueue(label: "ProxyApiTestsGolubInstanceManager")
  private let identifiers: NSMapTable<AnyObject, NSNumber> = NSMapTable(
    keyOptions: [.weakMemory, .objectPointerPersonality], valueOptions: .strongMemory)
  private let weakInstances: NSMapTable<NSNumber, AnyObject> = NSMapTable(
    keyOptions: .strongMemory, valueOptions: [.weakMemory, .objectPointerPersonality])
  private let strongInstances: NSMapTable<NSNumber, AnyObject> = NSMapTable(
    keyOptions: .strongMemory, valueOptions: [.strongMemory, .objectPointerPersonality])
  private let finalizerDelegate: ProxyApiTestsGolubInternalFinalizerDelegate
  private var nextIdentifier: Int64 = minHostCreatedIdentifier

  public init(finalizerDelegate: ProxyApiTestsGolubInternalFinalizerDelegate) {
    self.finalizerDelegate = finalizerDelegate
  }

  /// Adds a new instance that was instantiated from Dart.
  ///
  /// The same instance can be added multiple times, but each identifier must be unique. This allows
  /// two objects that are equivalent (e.g. conforms to `Equatable`)  to both be added.
  ///
  /// - Parameters:
  ///   - instance: the instance to be stored
  ///   - identifier: the identifier to be paired with instance. This value must be >= 0 and unique
  func addDartCreatedInstance(_ instance: AnyObject, withIdentifier identifier: Int64) {
    lockQueue.async {
      self.addInstance(instance, withIdentifier: identifier)
    }
  }

  /// Adds a new instance that was instantiated from the host platform.
  ///
  /// - Parameters:
  ///   - instance: the instance to be stored. This must be unique to all other added instances.
  /// - Returns: the unique identifier (>= 0) stored with instance
  func addHostCreatedInstance(_ instance: AnyObject) -> Int64 {
    assert(!containsInstance(instance), "Instance of \(instance) has already been added.")
    var identifier: Int64 = -1
    lockQueue.sync {
      identifier = nextIdentifier
      nextIdentifier += 1
      self.addInstance(instance, withIdentifier: identifier)
    }
    return identifier
  }

  /// Removes `instanceIdentifier` and its associated strongly referenced instance, if present, from the manager.
  ///
  /// - Parameters:
  ///   - instanceIdentifier: the identifier paired to an instance.
  /// - Returns: removed instance if the manager contains the given identifier, otherwise `nil` if
  ///   the manager doesn't contain the value
  func removeInstance<T: AnyObject>(withIdentifier instanceIdentifier: Int64) throws -> T? {
    var instance: AnyObject? = nil
    lockQueue.sync {
      instance = strongInstances.object(forKey: NSNumber(value: instanceIdentifier))
      strongInstances.removeObject(forKey: NSNumber(value: instanceIdentifier))
    }
    return instance as? T
  }

  /// Retrieves the instance associated with identifier.
  ///
  /// - Parameters:
  ///   - instanceIdentifier: the identifier associated with an instance
  /// - Returns: the instance associated with `instanceIdentifier` if the manager contains the value, otherwise
  ///   `nil` if the manager doesn't contain the value
  func instance<T: AnyObject>(forIdentifier instanceIdentifier: Int64) -> T? {
    var instance: AnyObject? = nil
    lockQueue.sync {
      instance = weakInstances.object(forKey: NSNumber(value: instanceIdentifier))
    }
    return instance as? T
  }

  private func addInstance(_ instance: AnyObject, withIdentifier identifier: Int64) {
    assert(identifier >= 0)
    assert(
      weakInstances.object(forKey: identifier as NSNumber) == nil,
      "Identifier has already been added: \(identifier)")
    identifiers.setObject(NSNumber(value: identifier), forKey: instance)
    weakInstances.setObject(instance, forKey: NSNumber(value: identifier))
    strongInstances.setObject(instance, forKey: NSNumber(value: identifier))
    ProxyApiTestsGolubInternalFinalizer.attach(
      to: instance, identifier: identifier, delegate: finalizerDelegate)
  }

  /// Retrieves the identifier paired with an instance.
  ///
  /// If the manager contains a strong reference to `instance`, it will return the identifier
  /// associated with `instance`. If the manager contains only a weak reference to `instance`, a new
  /// strong reference to `instance` will be added and will need to be removed again with `removeInstance`.
  ///
  /// If this method returns a nonnull identifier, this method also expects the Dart
  /// `ProxyApiTestsGolubInstanceManager` to have, or recreate, a weak reference to the Dart instance the
  /// identifier is associated with.
  ///
  /// - Parameters:
  ///   - instance: an instance that may be stored in the manager
  /// - Returns: the identifier associated with `instance` if the manager contains the value, otherwise
  ///   `nil` if the manager doesn't contain the value
  func identifierWithStrongReference(forInstance instance: AnyObject) -> Int64? {
    var identifier: Int64? = nil
    lockQueue.sync {
      if let existingIdentifier = identifiers.object(forKey: instance)?.int64Value {
        strongInstances.setObject(instance, forKey: NSNumber(value: existingIdentifier))
        identifier = existingIdentifier
      }
    }
    return identifier
  }

  /// Whether this manager contains the given `instance`.
  ///
  /// - Parameters:
  ///   - instance: the instance whose presence in this manager is to be tested
  /// - Returns: whether this manager contains the given `instance`
  func containsInstance(_ instance: AnyObject) -> Bool {
    var containsInstance = false
    lockQueue.sync {
      containsInstance = identifiers.object(forKey: instance) != nil
    }
    return containsInstance
  }

  /// Removes all of the instances from this manager.
  ///
  /// The manager will be empty after this call returns.
  func removeAllObjects() throws {
    lockQueue.sync {
      let weakInstancesEnumerator = weakInstances.objectEnumerator()!
      while let instance = weakInstancesEnumerator.nextObject() {
        ProxyApiTestsGolubInternalFinalizer.detach(from: instance as AnyObject)
      }
      identifiers.removeAllObjects()
      weakInstances.removeAllObjects()
      strongInstances.removeAllObjects()
      nextIdentifier = ProxyApiTestsGolubInstanceManager.minHostCreatedIdentifier
    }
  }

  /// The number of instances stored as a strong reference.
  ///
  /// For debugging and testing purposes.
  internal var strongInstanceCount: Int {
    var count: Int = 0
    lockQueue.sync {
      count = strongInstances.count
    }
    return count
  }

  /// The number of instances stored as a weak reference.
  ///
  /// For debugging and testing purposes. NSMapTables that store keys or objects as weak
  /// reference will be reclaimed non-deterministically.
  internal var weakInstanceCount: Int {
    var count: Int = 0
    lockQueue.sync {
      count = weakInstances.count
    }
    return count
  }
}

private class ProxyApiTestsGolubInstanceManagerApi {
  /// The codec used for serializing messages.
  var codec: FlutterStandardMessageCodec { ProxyApiTestsGolubCodec.shared }

  /// Handles sending and receiving messages with Dart.
  unowned let binaryMessenger: FlutterBinaryMessenger

  init(binaryMessenger: FlutterBinaryMessenger) {
    self.binaryMessenger = binaryMessenger
  }

  /// Sets up an instance of `ProxyApiTestsGolubInstanceManagerApi` to handle messages through the `binaryMessenger`.
  static func setUpMessageHandlers(
    binaryMessenger: FlutterBinaryMessenger, instanceManager: ProxyApiTestsGolubInstanceManager?
  ) {
    let codec = ProxyApiTestsGolubCodec.shared
    let removeStrongReferenceChannel = FlutterBasicMessageChannel(
      name:
        "dev.bayori.golub.golub_integration_tests.GolubInternalInstanceManager.removeStrongReference",
      binaryMessenger: binaryMessenger, codec: codec)
    if let instanceManager = instanceManager {
      removeStrongReferenceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let identifierArg = args[0] as! Int64
        do {
          let _: AnyObject? = try instanceManager.removeInstance(withIdentifier: identifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeStrongReferenceChannel.setMessageHandler(nil)
    }
    let clearChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.GolubInternalInstanceManager.clear",
      binaryMessenger: binaryMessenger, codec: codec)
    if let instanceManager = instanceManager {
      clearChannel.setMessageHandler { _, reply in
        do {
          try instanceManager.removeAllObjects()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      clearChannel.setMessageHandler(nil)
    }
  }

  /// Sends a message to the Dart `InstanceManager` to remove the strong reference of the instance associated with `identifier`.
  public func removeStrongReference(
    identifier identifierArg: Int64,
    completion: @escaping (Result<Void, ProxyApiTestsError>) -> Void
  ) {
    let channelName: String =
      "dev.bayori.golub.golub_integration_tests.GolubInternalInstanceManager.removeStrongReference"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([identifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(ProxyApiTestsError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
}
protocol ProxyApiTestsGolubProxyApiDelegate {
  /// An implementation of [GolubApiProxyApiTestClass] used to add a new Dart instance of
  /// `ProxyApiTestClass` to the Dart `InstanceManager` and make calls to Dart.
  func golubApiProxyApiTestClass(_ registrar: ProxyApiTestsGolubProxyApiRegistrar)
    -> GolubApiProxyApiTestClass
  /// An implementation of [GolubApiProxyApiSuperClass] used to add a new Dart instance of
  /// `ProxyApiSuperClass` to the Dart `InstanceManager` and make calls to Dart.
  func golubApiProxyApiSuperClass(_ registrar: ProxyApiTestsGolubProxyApiRegistrar)
    -> GolubApiProxyApiSuperClass
  /// An implementation of [GolubApiProxyApiInterface] used to add a new Dart instance of
  /// `ProxyApiInterface` to the Dart `InstanceManager` and make calls to Dart.
  func golubApiProxyApiInterface(_ registrar: ProxyApiTestsGolubProxyApiRegistrar)
    -> GolubApiProxyApiInterface
  /// An implementation of [GolubApiClassWithApiRequirement] used to add a new Dart instance of
  /// `ClassWithApiRequirement` to the Dart `InstanceManager` and make calls to Dart.
  func golubApiClassWithApiRequirement(_ registrar: ProxyApiTestsGolubProxyApiRegistrar)
    -> GolubApiClassWithApiRequirement
}

extension ProxyApiTestsGolubProxyApiDelegate {
  func golubApiProxyApiInterface(_ registrar: ProxyApiTestsGolubProxyApiRegistrar)
    -> GolubApiProxyApiInterface
  {
    return GolubApiProxyApiInterface(
      golubRegistrar: registrar, delegate: GolubApiDelegateProxyApiInterface())
  }
}

open class ProxyApiTestsGolubProxyApiRegistrar {
  let binaryMessenger: FlutterBinaryMessenger
  let apiDelegate: ProxyApiTestsGolubProxyApiDelegate
  let instanceManager: ProxyApiTestsGolubInstanceManager
  /// Whether APIs should ignore calling to Dart.
  public var ignoreCallsToDart = false
  private var _codec: FlutterStandardMessageCodec?
  var codec: FlutterStandardMessageCodec {
    if _codec == nil {
      _codec = FlutterStandardMessageCodec(
        readerWriter: ProxyApiTestsGolubInternalProxyApiCodecReaderWriter(golubRegistrar: self))
    }
    return _codec!
  }

  private class InstanceManagerApiFinalizerDelegate: ProxyApiTestsGolubInternalFinalizerDelegate {
    let api: ProxyApiTestsGolubInstanceManagerApi

    init(_ api: ProxyApiTestsGolubInstanceManagerApi) {
      self.api = api
    }

    public func onDeinit(identifier: Int64) {
      api.removeStrongReference(identifier: identifier) {
        _ in
      }
    }
  }

  init(binaryMessenger: FlutterBinaryMessenger, apiDelegate: ProxyApiTestsGolubProxyApiDelegate) {
    self.binaryMessenger = binaryMessenger
    self.apiDelegate = apiDelegate
    self.instanceManager = ProxyApiTestsGolubInstanceManager(
      finalizerDelegate: InstanceManagerApiFinalizerDelegate(
        ProxyApiTestsGolubInstanceManagerApi(binaryMessenger: binaryMessenger)))
  }

  func setUp() {
    ProxyApiTestsGolubInstanceManagerApi.setUpMessageHandlers(
      binaryMessenger: binaryMessenger, instanceManager: instanceManager)
    GolubApiProxyApiTestClass.setUpMessageHandlers(
      binaryMessenger: binaryMessenger, api: apiDelegate.golubApiProxyApiTestClass(self))
    GolubApiProxyApiSuperClass.setUpMessageHandlers(
      binaryMessenger: binaryMessenger, api: apiDelegate.golubApiProxyApiSuperClass(self))
    GolubApiClassWithApiRequirement.setUpMessageHandlers(
      binaryMessenger: binaryMessenger, api: apiDelegate.golubApiClassWithApiRequirement(self))
  }
  func tearDown() {
    ProxyApiTestsGolubInstanceManagerApi.setUpMessageHandlers(
      binaryMessenger: binaryMessenger, instanceManager: nil)
    GolubApiProxyApiTestClass.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    GolubApiProxyApiSuperClass.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    GolubApiClassWithApiRequirement.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
  }
}
private class ProxyApiTestsGolubInternalProxyApiCodecReaderWriter: FlutterStandardReaderWriter {
  unowned let golubRegistrar: ProxyApiTestsGolubProxyApiRegistrar

  private class ProxyApiTestsGolubInternalProxyApiCodecReader: ProxyApiTestsGolubCodecReader {
    unowned let golubRegistrar: ProxyApiTestsGolubProxyApiRegistrar

    init(data: Data, golubRegistrar: ProxyApiTestsGolubProxyApiRegistrar) {
      self.golubRegistrar = golubRegistrar
      super.init(data: data)
    }

    override func readValue(ofType type: UInt8) -> Any? {
      switch type {
      case 128:
        let identifier = self.readValue()
        let instance: AnyObject? = golubRegistrar.instanceManager.instance(
          forIdentifier: identifier is Int64 ? identifier as! Int64 : Int64(identifier as! Int32))
        if instance == nil {
          print("Failed to find instance with identifier: \(identifier!)")
        }
        return instance
      default:
        return super.readValue(ofType: type)
      }
    }
  }

  private class ProxyApiTestsGolubInternalProxyApiCodecWriter: ProxyApiTestsGolubCodecWriter {
    unowned let golubRegistrar: ProxyApiTestsGolubProxyApiRegistrar

    init(data: NSMutableData, golubRegistrar: ProxyApiTestsGolubProxyApiRegistrar) {
      self.golubRegistrar = golubRegistrar
      super.init(data: data)
    }

    override func writeValue(_ value: Any) {
      if value is [Any] || value is Bool || value is Data || value is [AnyHashable: Any]
        || value is Double || value is FlutterStandardTypedData || value is Int64 || value is String
        || value is ProxyApiTestEnum
      {
        super.writeValue(value)
        return
      }

      if let instance = value as? ProxyApiTestClass {
        golubRegistrar.apiDelegate.golubApiProxyApiTestClass(golubRegistrar).golubNewInstance(
          golubInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          golubRegistrar.instanceManager.identifierWithStrongReference(
            forInstance: instance as AnyObject)!)
        return
      }

      if let instance = value as? ProxyApiSuperClass {
        golubRegistrar.apiDelegate.golubApiProxyApiSuperClass(golubRegistrar).golubNewInstance(
          golubInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          golubRegistrar.instanceManager.identifierWithStrongReference(
            forInstance: instance as AnyObject)!)
        return
      }

      if let instance = value as? ProxyApiInterface {
        golubRegistrar.apiDelegate.golubApiProxyApiInterface(golubRegistrar).golubNewInstance(
          golubInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          golubRegistrar.instanceManager.identifierWithStrongReference(
            forInstance: instance as AnyObject)!)
        return
      }

      if #available(iOS 15.0.0, macOS 10.0.0, *), let instance = value as? ClassWithApiRequirement {
        golubRegistrar.apiDelegate.golubApiClassWithApiRequirement(golubRegistrar).golubNewInstance(
          golubInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          golubRegistrar.instanceManager.identifierWithStrongReference(
            forInstance: instance as AnyObject)!)
        return
      }

      if let instance = value as AnyObject?,
        golubRegistrar.instanceManager.containsInstance(instance)
      {
        super.writeByte(128)
        super.writeValue(
          golubRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance)!)
      } else {
        print("Unsupported value: \(value) of \(type(of: value))")
        assert(false, "Unsupported value for ProxyApiTestsGolubInternalProxyApiCodecWriter")
      }

    }
  }

  init(golubRegistrar: ProxyApiTestsGolubProxyApiRegistrar) {
    self.golubRegistrar = golubRegistrar
  }

  override func reader(with data: Data) -> FlutterStandardReader {
    return ProxyApiTestsGolubInternalProxyApiCodecReader(data: data, golubRegistrar: golubRegistrar)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return ProxyApiTestsGolubInternalProxyApiCodecWriter(data: data, golubRegistrar: golubRegistrar)
  }
}

public enum ProxyApiTestEnum: Int {
  case one = 0
  case two = 1
  case three = 2
}

private class ProxyApiTestsGolubCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ProxyApiTestEnum(rawValue: enumResultAsInt)
      }
      return nil
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class ProxyApiTestsGolubCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? ProxyApiTestEnum {
      super.writeByte(129)
      super.writeValue(value.rawValue)
    } else {
      super.writeValue(value)
    }
  }
}

private class ProxyApiTestsGolubCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return ProxyApiTestsGolubCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return ProxyApiTestsGolubCodecWriter(data: data)
  }
}

class ProxyApiTestsGolubCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = ProxyApiTestsGolubCodec(readerWriter: ProxyApiTestsGolubCodecReaderWriter())
}

protocol GolubApiDelegateProxyApiTestClass {
  func golubDefaultConstructor(
    golubApi: GolubApiProxyApiTestClass, aBool: Bool, anInt: Int64, aDouble: Double,
    aString: String, aUint8List: FlutterStandardTypedData, aList: [Any?], aMap: [String?: Any?],
    anEnum: ProxyApiTestEnum, aProxyApi: ProxyApiSuperClass, aNullableBool: Bool?,
    aNullableInt: Int64?, aNullableDouble: Double?, aNullableString: String?,
    aNullableUint8List: FlutterStandardTypedData?, aNullableList: [Any?]?,
    aNullableMap: [String?: Any?]?, aNullableEnum: ProxyApiTestEnum?,
    aNullableProxyApi: ProxyApiSuperClass?, boolParam: Bool, intParam: Int64, doubleParam: Double,
    stringParam: String, aUint8ListParam: FlutterStandardTypedData, listParam: [Any?],
    mapParam: [String?: Any?], enumParam: ProxyApiTestEnum, proxyApiParam: ProxyApiSuperClass,
    nullableBoolParam: Bool?, nullableIntParam: Int64?, nullableDoubleParam: Double?,
    nullableStringParam: String?, nullableUint8ListParam: FlutterStandardTypedData?,
    nullableListParam: [Any?]?, nullableMapParam: [String?: Any?]?,
    nullableEnumParam: ProxyApiTestEnum?, nullableProxyApiParam: ProxyApiSuperClass?
  ) throws -> ProxyApiTestClass
  func namedConstructor(
    golubApi: GolubApiProxyApiTestClass, aBool: Bool, anInt: Int64, aDouble: Double,
    aString: String, aUint8List: FlutterStandardTypedData, aList: [Any?], aMap: [String?: Any?],
    anEnum: ProxyApiTestEnum, aProxyApi: ProxyApiSuperClass, aNullableBool: Bool?,
    aNullableInt: Int64?, aNullableDouble: Double?, aNullableString: String?,
    aNullableUint8List: FlutterStandardTypedData?, aNullableList: [Any?]?,
    aNullableMap: [String?: Any?]?, aNullableEnum: ProxyApiTestEnum?,
    aNullableProxyApi: ProxyApiSuperClass?
  ) throws -> ProxyApiTestClass
  func attachedField(golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass) throws
    -> ProxyApiSuperClass
  func staticAttachedField(golubApi: GolubApiProxyApiTestClass) throws -> ProxyApiSuperClass
  /// A no-op function taking no arguments and returning no value, to sanity
  /// test basic calling.
  func noop(golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass) throws
  /// Returns an error, to test error handling.
  func throwError(golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass) throws
    -> Any?
  /// Returns an error from a void function, to test error handling.
  func throwErrorFromVoid(golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass)
    throws
  /// Returns a Flutter error, to test error handling.
  func throwFlutterError(golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass)
    throws -> Any?
  /// Returns passed in int.
  func echoInt(golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, anInt: Int64)
    throws -> Int64
  /// Returns passed in double.
  func echoDouble(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, aDouble: Double
  ) throws -> Double
  /// Returns the passed in boolean.
  func echoBool(golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, aBool: Bool)
    throws -> Bool
  /// Returns the passed in string.
  func echoString(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, aString: String
  ) throws -> String
  /// Returns the passed in Uint8List.
  func echoUint8List(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass,
    aUint8List: FlutterStandardTypedData
  ) throws -> FlutterStandardTypedData
  /// Returns the passed in generic Object.
  func echoObject(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, anObject: Any
  ) throws -> Any
  /// Returns the passed list, to test serialization and deserialization.
  func echoList(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, aList: [Any?]
  ) throws -> [Any?]
  /// Returns the passed list with ProxyApis, to test serialization and
  /// deserialization.
  func echoProxyApiList(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass,
    aList: [ProxyApiTestClass]
  ) throws -> [ProxyApiTestClass]
  /// Returns the passed map, to test serialization and deserialization.
  func echoMap(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, aMap: [String?: Any?]
  ) throws -> [String?: Any?]
  /// Returns the passed map with ProxyApis, to test serialization and
  /// deserialization.
  func echoProxyApiMap(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass,
    aMap: [String: ProxyApiTestClass]
  ) throws -> [String: ProxyApiTestClass]
  /// Returns the passed enum to test serialization and deserialization.
  func echoEnum(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, anEnum: ProxyApiTestEnum
  ) throws -> ProxyApiTestEnum
  /// Returns the passed ProxyApi to test serialization and deserialization.
  func echoProxyApi(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass,
    aProxyApi: ProxyApiSuperClass
  ) throws -> ProxyApiSuperClass
  /// Returns passed in int.
  func echoNullableInt(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, aNullableInt: Int64?
  ) throws -> Int64?
  /// Returns passed in double.
  func echoNullableDouble(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, aNullableDouble: Double?
  ) throws -> Double?
  /// Returns the passed in boolean.
  func echoNullableBool(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, aNullableBool: Bool?
  ) throws -> Bool?
  /// Returns the passed in string.
  func echoNullableString(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, aNullableString: String?
  ) throws -> String?
  /// Returns the passed in Uint8List.
  func echoNullableUint8List(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass,
    aNullableUint8List: FlutterStandardTypedData?
  ) throws -> FlutterStandardTypedData?
  /// Returns the passed in generic Object.
  func echoNullableObject(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, aNullableObject: Any?
  ) throws -> Any?
  /// Returns the passed list, to test serialization and deserialization.
  func echoNullableList(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, aNullableList: [Any?]?
  ) throws -> [Any?]?
  /// Returns the passed map, to test serialization and deserialization.
  func echoNullableMap(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass,
    aNullableMap: [String?: Any?]?
  ) throws -> [String?: Any?]?
  func echoNullableEnum(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass,
    aNullableEnum: ProxyApiTestEnum?
  ) throws -> ProxyApiTestEnum?
  /// Returns the passed ProxyApi to test serialization and deserialization.
  func echoNullableProxyApi(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass,
    aNullableProxyApi: ProxyApiSuperClass?
  ) throws -> ProxyApiSuperClass?
  /// A no-op function taking no arguments and returning no value, to sanity
  /// test basic asynchronous calling.
  func noopAsync(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass,
    completion: @escaping (Result<Void, Error>) -> Void)
  /// Returns passed in int asynchronously.
  func echoAsyncInt(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, anInt: Int64,
    completion: @escaping (Result<Int64, Error>) -> Void)
  /// Returns passed in double asynchronously.
  func echoAsyncDouble(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, aDouble: Double,
    completion: @escaping (Result<Double, Error>) -> Void)
  /// Returns the passed in boolean asynchronously.
  func echoAsyncBool(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, aBool: Bool,
    completion: @escaping (Result<Bool, Error>) -> Void)
  /// Returns the passed string asynchronously.
  func echoAsyncString(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, aString: String,
    completion: @escaping (Result<String, Error>) -> Void)
  /// Returns the passed in Uint8List asynchronously.
  func echoAsyncUint8List(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass,
    aUint8List: FlutterStandardTypedData,
    completion: @escaping (Result<FlutterStandardTypedData, Error>) -> Void)
  /// Returns the passed in generic Object asynchronously.
  func echoAsyncObject(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, anObject: Any,
    completion: @escaping (Result<Any, Error>) -> Void)
  /// Returns the passed list, to test asynchronous serialization and deserialization.
  func echoAsyncList(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, aList: [Any?],
    completion: @escaping (Result<[Any?], Error>) -> Void)
  /// Returns the passed map, to test asynchronous serialization and deserialization.
  func echoAsyncMap(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, aMap: [String?: Any?],
    completion: @escaping (Result<[String?: Any?], Error>) -> Void)
  /// Returns the passed enum, to test asynchronous serialization and deserialization.
  func echoAsyncEnum(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, anEnum: ProxyApiTestEnum,
    completion: @escaping (Result<ProxyApiTestEnum, Error>) -> Void)
  /// Responds with an error from an async function returning a value.
  func throwAsyncError(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass,
    completion: @escaping (Result<Any?, Error>) -> Void)
  /// Responds with an error from an async void function.
  func throwAsyncErrorFromVoid(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass,
    completion: @escaping (Result<Void, Error>) -> Void)
  /// Responds with a Flutter error from an async function returning a value.
  func throwAsyncFlutterError(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass,
    completion: @escaping (Result<Any?, Error>) -> Void)
  /// Returns passed in int asynchronously.
  func echoAsyncNullableInt(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, anInt: Int64?,
    completion: @escaping (Result<Int64?, Error>) -> Void)
  /// Returns passed in double asynchronously.
  func echoAsyncNullableDouble(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, aDouble: Double?,
    completion: @escaping (Result<Double?, Error>) -> Void)
  /// Returns the passed in boolean asynchronously.
  func echoAsyncNullableBool(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, aBool: Bool?,
    completion: @escaping (Result<Bool?, Error>) -> Void)
  /// Returns the passed string asynchronously.
  func echoAsyncNullableString(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, aString: String?,
    completion: @escaping (Result<String?, Error>) -> Void)
  /// Returns the passed in Uint8List asynchronously.
  func echoAsyncNullableUint8List(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass,
    aUint8List: FlutterStandardTypedData?,
    completion: @escaping (Result<FlutterStandardTypedData?, Error>) -> Void)
  /// Returns the passed in generic Object asynchronously.
  func echoAsyncNullableObject(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, anObject: Any?,
    completion: @escaping (Result<Any?, Error>) -> Void)
  /// Returns the passed list, to test asynchronous serialization and deserialization.
  func echoAsyncNullableList(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, aList: [Any?]?,
    completion: @escaping (Result<[Any?]?, Error>) -> Void)
  /// Returns the passed map, to test asynchronous serialization and deserialization.
  func echoAsyncNullableMap(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, aMap: [String?: Any?]?,
    completion: @escaping (Result<[String?: Any?]?, Error>) -> Void)
  /// Returns the passed enum, to test asynchronous serialization and deserialization.
  func echoAsyncNullableEnum(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass,
    anEnum: ProxyApiTestEnum?, completion: @escaping (Result<ProxyApiTestEnum?, Error>) -> Void)
  func staticNoop(golubApi: GolubApiProxyApiTestClass) throws
  func echoStaticString(golubApi: GolubApiProxyApiTestClass, aString: String) throws -> String
  func staticAsyncNoop(
    golubApi: GolubApiProxyApiTestClass, completion: @escaping (Result<Void, Error>) -> Void)
  func callFlutterNoop(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass,
    completion: @escaping (Result<Void, Error>) -> Void)
  func callFlutterThrowError(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass,
    completion: @escaping (Result<Any?, Error>) -> Void)
  func callFlutterThrowErrorFromVoid(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass,
    completion: @escaping (Result<Void, Error>) -> Void)
  func callFlutterEchoBool(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, aBool: Bool,
    completion: @escaping (Result<Bool, Error>) -> Void)
  func callFlutterEchoInt(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, anInt: Int64,
    completion: @escaping (Result<Int64, Error>) -> Void)
  func callFlutterEchoDouble(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, aDouble: Double,
    completion: @escaping (Result<Double, Error>) -> Void)
  func callFlutterEchoString(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, aString: String,
    completion: @escaping (Result<String, Error>) -> Void)
  func callFlutterEchoUint8List(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass,
    aUint8List: FlutterStandardTypedData,
    completion: @escaping (Result<FlutterStandardTypedData, Error>) -> Void)
  func callFlutterEchoList(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, aList: [Any?],
    completion: @escaping (Result<[Any?], Error>) -> Void)
  func callFlutterEchoProxyApiList(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass,
    aList: [ProxyApiTestClass?], completion: @escaping (Result<[ProxyApiTestClass?], Error>) -> Void
  )
  func callFlutterEchoMap(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, aMap: [String?: Any?],
    completion: @escaping (Result<[String?: Any?], Error>) -> Void)
  func callFlutterEchoProxyApiMap(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass,
    aMap: [String?: ProxyApiTestClass?],
    completion: @escaping (Result<[String?: ProxyApiTestClass?], Error>) -> Void)
  func callFlutterEchoEnum(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, anEnum: ProxyApiTestEnum,
    completion: @escaping (Result<ProxyApiTestEnum, Error>) -> Void)
  func callFlutterEchoProxyApi(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass,
    aProxyApi: ProxyApiSuperClass, completion: @escaping (Result<ProxyApiSuperClass, Error>) -> Void
  )
  func callFlutterEchoNullableBool(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, aBool: Bool?,
    completion: @escaping (Result<Bool?, Error>) -> Void)
  func callFlutterEchoNullableInt(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, anInt: Int64?,
    completion: @escaping (Result<Int64?, Error>) -> Void)
  func callFlutterEchoNullableDouble(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, aDouble: Double?,
    completion: @escaping (Result<Double?, Error>) -> Void)
  func callFlutterEchoNullableString(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, aString: String?,
    completion: @escaping (Result<String?, Error>) -> Void)
  func callFlutterEchoNullableUint8List(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass,
    aUint8List: FlutterStandardTypedData?,
    completion: @escaping (Result<FlutterStandardTypedData?, Error>) -> Void)
  func callFlutterEchoNullableList(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, aList: [Any?]?,
    completion: @escaping (Result<[Any?]?, Error>) -> Void)
  func callFlutterEchoNullableMap(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, aMap: [String?: Any?]?,
    completion: @escaping (Result<[String?: Any?]?, Error>) -> Void)
  func callFlutterEchoNullableEnum(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass,
    anEnum: ProxyApiTestEnum?, completion: @escaping (Result<ProxyApiTestEnum?, Error>) -> Void)
  func callFlutterEchoNullableProxyApi(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass,
    aProxyApi: ProxyApiSuperClass?,
    completion: @escaping (Result<ProxyApiSuperClass?, Error>) -> Void)
  func callFlutterNoopAsync(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass,
    completion: @escaping (Result<Void, Error>) -> Void)
  func callFlutterEchoAsyncString(
    golubApi: GolubApiProxyApiTestClass, golubInstance: ProxyApiTestClass, aString: String,
    completion: @escaping (Result<String, Error>) -> Void)
}

protocol GolubApiProtocolProxyApiTestClass {
  /// A no-op function taking no arguments and returning no value, to sanity
  /// test basic calling.
  func flutterNoop(
    golubInstance golubInstanceArg: ProxyApiTestClass,
    completion: @escaping (Result<Void, ProxyApiTestsError>) -> Void)
  /// Responds with an error from an async function returning a value.
  func flutterThrowError(
    golubInstance golubInstanceArg: ProxyApiTestClass,
    completion: @escaping (Result<Any?, ProxyApiTestsError>) -> Void)
  /// Responds with an error from an async void function.
  func flutterThrowErrorFromVoid(
    golubInstance golubInstanceArg: ProxyApiTestClass,
    completion: @escaping (Result<Void, ProxyApiTestsError>) -> Void)
  /// Returns the passed boolean, to test serialization and deserialization.
  func flutterEchoBool(
    golubInstance golubInstanceArg: ProxyApiTestClass, aBool aBoolArg: Bool,
    completion: @escaping (Result<Bool, ProxyApiTestsError>) -> Void)
  /// Returns the passed int, to test serialization and deserialization.
  func flutterEchoInt(
    golubInstance golubInstanceArg: ProxyApiTestClass, anInt anIntArg: Int64,
    completion: @escaping (Result<Int64, ProxyApiTestsError>) -> Void)
  /// Returns the passed double, to test serialization and deserialization.
  func flutterEchoDouble(
    golubInstance golubInstanceArg: ProxyApiTestClass, aDouble aDoubleArg: Double,
    completion: @escaping (Result<Double, ProxyApiTestsError>) -> Void)
  /// Returns the passed string, to test serialization and deserialization.
  func flutterEchoString(
    golubInstance golubInstanceArg: ProxyApiTestClass, aString aStringArg: String,
    completion: @escaping (Result<String, ProxyApiTestsError>) -> Void)
  /// Returns the passed byte list, to test serialization and deserialization.
  func flutterEchoUint8List(
    golubInstance golubInstanceArg: ProxyApiTestClass, aList aListArg: FlutterStandardTypedData,
    completion: @escaping (Result<FlutterStandardTypedData, ProxyApiTestsError>) -> Void)
  /// Returns the passed list, to test serialization and deserialization.
  func flutterEchoList(
    golubInstance golubInstanceArg: ProxyApiTestClass, aList aListArg: [Any?],
    completion: @escaping (Result<[Any?], ProxyApiTestsError>) -> Void)
  /// Returns the passed list with ProxyApis, to test serialization and
  /// deserialization.
  func flutterEchoProxyApiList(
    golubInstance golubInstanceArg: ProxyApiTestClass, aList aListArg: [ProxyApiTestClass?],
    completion: @escaping (Result<[ProxyApiTestClass?], ProxyApiTestsError>) -> Void)
  /// Returns the passed map, to test serialization and deserialization.
  func flutterEchoMap(
    golubInstance golubInstanceArg: ProxyApiTestClass, aMap aMapArg: [String?: Any?],
    completion: @escaping (Result<[String?: Any?], ProxyApiTestsError>) -> Void)
  /// Returns the passed map with ProxyApis, to test serialization and
  /// deserialization.
  func flutterEchoProxyApiMap(
    golubInstance golubInstanceArg: ProxyApiTestClass, aMap aMapArg: [String?: ProxyApiTestClass?],
    completion: @escaping (Result<[String?: ProxyApiTestClass?], ProxyApiTestsError>) -> Void)
  /// Returns the passed enum to test serialization and deserialization.
  func flutterEchoEnum(
    golubInstance golubInstanceArg: ProxyApiTestClass, anEnum anEnumArg: ProxyApiTestEnum,
    completion: @escaping (Result<ProxyApiTestEnum, ProxyApiTestsError>) -> Void)
  /// Returns the passed ProxyApi to test serialization and deserialization.
  func flutterEchoProxyApi(
    golubInstance golubInstanceArg: ProxyApiTestClass, aProxyApi aProxyApiArg: ProxyApiSuperClass,
    completion: @escaping (Result<ProxyApiSuperClass, ProxyApiTestsError>) -> Void)
  /// Returns the passed boolean, to test serialization and deserialization.
  func flutterEchoNullableBool(
    golubInstance golubInstanceArg: ProxyApiTestClass, aBool aBoolArg: Bool?,
    completion: @escaping (Result<Bool?, ProxyApiTestsError>) -> Void)
  /// Returns the passed int, to test serialization and deserialization.
  func flutterEchoNullableInt(
    golubInstance golubInstanceArg: ProxyApiTestClass, anInt anIntArg: Int64?,
    completion: @escaping (Result<Int64?, ProxyApiTestsError>) -> Void)
  /// Returns the passed double, to test serialization and deserialization.
  func flutterEchoNullableDouble(
    golubInstance golubInstanceArg: ProxyApiTestClass, aDouble aDoubleArg: Double?,
    completion: @escaping (Result<Double?, ProxyApiTestsError>) -> Void)
  /// Returns the passed string, to test serialization and deserialization.
  func flutterEchoNullableString(
    golubInstance golubInstanceArg: ProxyApiTestClass, aString aStringArg: String?,
    completion: @escaping (Result<String?, ProxyApiTestsError>) -> Void)
  /// Returns the passed byte list, to test serialization and deserialization.
  func flutterEchoNullableUint8List(
    golubInstance golubInstanceArg: ProxyApiTestClass, aList aListArg: FlutterStandardTypedData?,
    completion: @escaping (Result<FlutterStandardTypedData?, ProxyApiTestsError>) -> Void)
  /// Returns the passed list, to test serialization and deserialization.
  func flutterEchoNullableList(
    golubInstance golubInstanceArg: ProxyApiTestClass, aList aListArg: [Any?]?,
    completion: @escaping (Result<[Any?]?, ProxyApiTestsError>) -> Void)
  /// Returns the passed map, to test serialization and deserialization.
  func flutterEchoNullableMap(
    golubInstance golubInstanceArg: ProxyApiTestClass, aMap aMapArg: [String?: Any?]?,
    completion: @escaping (Result<[String?: Any?]?, ProxyApiTestsError>) -> Void)
  /// Returns the passed enum to test serialization and deserialization.
  func flutterEchoNullableEnum(
    golubInstance golubInstanceArg: ProxyApiTestClass, anEnum anEnumArg: ProxyApiTestEnum?,
    completion: @escaping (Result<ProxyApiTestEnum?, ProxyApiTestsError>) -> Void)
  /// Returns the passed ProxyApi to test serialization and deserialization.
  func flutterEchoNullableProxyApi(
    golubInstance golubInstanceArg: ProxyApiTestClass, aProxyApi aProxyApiArg: ProxyApiSuperClass?,
    completion: @escaping (Result<ProxyApiSuperClass?, ProxyApiTestsError>) -> Void)
  /// A no-op function taking no arguments and returning no value, to sanity
  /// test basic asynchronous calling.
  func flutterNoopAsync(
    golubInstance golubInstanceArg: ProxyApiTestClass,
    completion: @escaping (Result<Void, ProxyApiTestsError>) -> Void)
  /// Returns the passed in generic Object asynchronously.
  func flutterEchoAsyncString(
    golubInstance golubInstanceArg: ProxyApiTestClass, aString aStringArg: String,
    completion: @escaping (Result<String, ProxyApiTestsError>) -> Void)
}

final class GolubApiProxyApiTestClass: GolubApiProtocolProxyApiTestClass {
  unowned let golubRegistrar: ProxyApiTestsGolubProxyApiRegistrar
  let golubDelegate: GolubApiDelegateProxyApiTestClass
  ///An implementation of [ProxyApiSuperClass] used to access callback methods
  var golubApiProxyApiSuperClass: GolubApiProxyApiSuperClass {
    return golubRegistrar.apiDelegate.golubApiProxyApiSuperClass(golubRegistrar)
  }

  ///An implementation of [ProxyApiInterface] used to access callback methods
  var golubApiProxyApiInterface: GolubApiProxyApiInterface {
    return golubRegistrar.apiDelegate.golubApiProxyApiInterface(golubRegistrar)
  }

  init(
    golubRegistrar: ProxyApiTestsGolubProxyApiRegistrar, delegate: GolubApiDelegateProxyApiTestClass
  ) {
    self.golubRegistrar = golubRegistrar
    self.golubDelegate = delegate
  }
  static func setUpMessageHandlers(
    binaryMessenger: FlutterBinaryMessenger, api: GolubApiProxyApiTestClass?
  ) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: ProxyApiTestsGolubInternalProxyApiCodecReaderWriter(
          golubRegistrar: api!.golubRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let golubDefaultConstructorChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.golub_defaultConstructor",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      golubDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubIdentifierArg = args[0] as! Int64
        let aBoolArg = args[1] as! Bool
        let anIntArg = args[2] as! Int64
        let aDoubleArg = args[3] as! Double
        let aStringArg = args[4] as! String
        let aUint8ListArg = args[5] as! FlutterStandardTypedData
        let aListArg = args[6] as! [Any?]
        let aMapArg = args[7] as! [String?: Any?]
        let anEnumArg = args[8] as! ProxyApiTestEnum
        let aProxyApiArg = args[9] as! ProxyApiSuperClass
        let aNullableBoolArg: Bool? = nilOrValue(args[10])
        let aNullableIntArg: Int64? = nilOrValue(args[11])
        let aNullableDoubleArg: Double? = nilOrValue(args[12])
        let aNullableStringArg: String? = nilOrValue(args[13])
        let aNullableUint8ListArg: FlutterStandardTypedData? = nilOrValue(args[14])
        let aNullableListArg: [Any?]? = nilOrValue(args[15])
        let aNullableMapArg: [String?: Any?]? = nilOrValue(args[16])
        let aNullableEnumArg: ProxyApiTestEnum? = nilOrValue(args[17])
        let aNullableProxyApiArg: ProxyApiSuperClass? = nilOrValue(args[18])
        let boolParamArg = args[19] as! Bool
        let intParamArg = args[20] as! Int64
        let doubleParamArg = args[21] as! Double
        let stringParamArg = args[22] as! String
        let aUint8ListParamArg = args[23] as! FlutterStandardTypedData
        let listParamArg = args[24] as! [Any?]
        let mapParamArg = args[25] as! [String?: Any?]
        let enumParamArg = args[26] as! ProxyApiTestEnum
        let proxyApiParamArg = args[27] as! ProxyApiSuperClass
        let nullableBoolParamArg: Bool? = nilOrValue(args[28])
        let nullableIntParamArg: Int64? = nilOrValue(args[29])
        let nullableDoubleParamArg: Double? = nilOrValue(args[30])
        let nullableStringParamArg: String? = nilOrValue(args[31])
        let nullableUint8ListParamArg: FlutterStandardTypedData? = nilOrValue(args[32])
        let nullableListParamArg: [Any?]? = nilOrValue(args[33])
        let nullableMapParamArg: [String?: Any?]? = nilOrValue(args[34])
        let nullableEnumParamArg: ProxyApiTestEnum? = nilOrValue(args[35])
        let nullableProxyApiParamArg: ProxyApiSuperClass? = nilOrValue(args[36])
        do {
          api.golubRegistrar.instanceManager.addDartCreatedInstance(
            try api.golubDelegate.golubDefaultConstructor(
              golubApi: api, aBool: aBoolArg, anInt: anIntArg, aDouble: aDoubleArg,
              aString: aStringArg, aUint8List: aUint8ListArg, aList: aListArg, aMap: aMapArg,
              anEnum: anEnumArg, aProxyApi: aProxyApiArg, aNullableBool: aNullableBoolArg,
              aNullableInt: aNullableIntArg, aNullableDouble: aNullableDoubleArg,
              aNullableString: aNullableStringArg, aNullableUint8List: aNullableUint8ListArg,
              aNullableList: aNullableListArg, aNullableMap: aNullableMapArg,
              aNullableEnum: aNullableEnumArg, aNullableProxyApi: aNullableProxyApiArg,
              boolParam: boolParamArg, intParam: intParamArg, doubleParam: doubleParamArg,
              stringParam: stringParamArg, aUint8ListParam: aUint8ListParamArg,
              listParam: listParamArg, mapParam: mapParamArg, enumParam: enumParamArg,
              proxyApiParam: proxyApiParamArg, nullableBoolParam: nullableBoolParamArg,
              nullableIntParam: nullableIntParamArg, nullableDoubleParam: nullableDoubleParamArg,
              nullableStringParam: nullableStringParamArg,
              nullableUint8ListParam: nullableUint8ListParamArg,
              nullableListParam: nullableListParamArg, nullableMapParam: nullableMapParamArg,
              nullableEnumParam: nullableEnumParamArg,
              nullableProxyApiParam: nullableProxyApiParamArg),
            withIdentifier: golubIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      golubDefaultConstructorChannel.setMessageHandler(nil)
    }
    let namedConstructorChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.namedConstructor",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      namedConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubIdentifierArg = args[0] as! Int64
        let aBoolArg = args[1] as! Bool
        let anIntArg = args[2] as! Int64
        let aDoubleArg = args[3] as! Double
        let aStringArg = args[4] as! String
        let aUint8ListArg = args[5] as! FlutterStandardTypedData
        let aListArg = args[6] as! [Any?]
        let aMapArg = args[7] as! [String?: Any?]
        let anEnumArg = args[8] as! ProxyApiTestEnum
        let aProxyApiArg = args[9] as! ProxyApiSuperClass
        let aNullableBoolArg: Bool? = nilOrValue(args[10])
        let aNullableIntArg: Int64? = nilOrValue(args[11])
        let aNullableDoubleArg: Double? = nilOrValue(args[12])
        let aNullableStringArg: String? = nilOrValue(args[13])
        let aNullableUint8ListArg: FlutterStandardTypedData? = nilOrValue(args[14])
        let aNullableListArg: [Any?]? = nilOrValue(args[15])
        let aNullableMapArg: [String?: Any?]? = nilOrValue(args[16])
        let aNullableEnumArg: ProxyApiTestEnum? = nilOrValue(args[17])
        let aNullableProxyApiArg: ProxyApiSuperClass? = nilOrValue(args[18])
        do {
          api.golubRegistrar.instanceManager.addDartCreatedInstance(
            try api.golubDelegate.namedConstructor(
              golubApi: api, aBool: aBoolArg, anInt: anIntArg, aDouble: aDoubleArg,
              aString: aStringArg, aUint8List: aUint8ListArg, aList: aListArg, aMap: aMapArg,
              anEnum: anEnumArg, aProxyApi: aProxyApiArg, aNullableBool: aNullableBoolArg,
              aNullableInt: aNullableIntArg, aNullableDouble: aNullableDoubleArg,
              aNullableString: aNullableStringArg, aNullableUint8List: aNullableUint8ListArg,
              aNullableList: aNullableListArg, aNullableMap: aNullableMapArg,
              aNullableEnum: aNullableEnumArg, aNullableProxyApi: aNullableProxyApiArg),
            withIdentifier: golubIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      namedConstructorChannel.setMessageHandler(nil)
    }
    let attachedFieldChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.attachedField",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      attachedFieldChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let golubIdentifierArg = args[1] as! Int64
        do {
          api.golubRegistrar.instanceManager.addDartCreatedInstance(
            try api.golubDelegate.attachedField(golubApi: api, golubInstance: golubInstanceArg),
            withIdentifier: golubIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      attachedFieldChannel.setMessageHandler(nil)
    }
    let staticAttachedFieldChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.staticAttachedField",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      staticAttachedFieldChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubIdentifierArg = args[0] as! Int64
        do {
          api.golubRegistrar.instanceManager.addDartCreatedInstance(
            try api.golubDelegate.staticAttachedField(golubApi: api),
            withIdentifier: golubIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      staticAttachedFieldChannel.setMessageHandler(nil)
    }
    let noopChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.noop",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      noopChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        do {
          try api.golubDelegate.noop(golubApi: api, golubInstance: golubInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      noopChannel.setMessageHandler(nil)
    }
    let throwErrorChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.throwError",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      throwErrorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        do {
          let result = try api.golubDelegate.throwError(
            golubApi: api, golubInstance: golubInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      throwErrorChannel.setMessageHandler(nil)
    }
    let throwErrorFromVoidChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.throwErrorFromVoid",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      throwErrorFromVoidChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        do {
          try api.golubDelegate.throwErrorFromVoid(golubApi: api, golubInstance: golubInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      throwErrorFromVoidChannel.setMessageHandler(nil)
    }
    let throwFlutterErrorChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.throwFlutterError",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      throwFlutterErrorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        do {
          let result = try api.golubDelegate.throwFlutterError(
            golubApi: api, golubInstance: golubInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      throwFlutterErrorChannel.setMessageHandler(nil)
    }
    let echoIntChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoInt",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoIntChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let anIntArg = args[1] as! Int64
        do {
          let result = try api.golubDelegate.echoInt(
            golubApi: api, golubInstance: golubInstanceArg, anInt: anIntArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoIntChannel.setMessageHandler(nil)
    }
    let echoDoubleChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoDouble",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoDoubleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aDoubleArg = args[1] as! Double
        do {
          let result = try api.golubDelegate.echoDouble(
            golubApi: api, golubInstance: golubInstanceArg, aDouble: aDoubleArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoDoubleChannel.setMessageHandler(nil)
    }
    let echoBoolChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoBool",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoBoolChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aBoolArg = args[1] as! Bool
        do {
          let result = try api.golubDelegate.echoBool(
            golubApi: api, golubInstance: golubInstanceArg, aBool: aBoolArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoBoolChannel.setMessageHandler(nil)
    }
    let echoStringChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoString",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoStringChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aStringArg = args[1] as! String
        do {
          let result = try api.golubDelegate.echoString(
            golubApi: api, golubInstance: golubInstanceArg, aString: aStringArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoStringChannel.setMessageHandler(nil)
    }
    let echoUint8ListChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoUint8List",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoUint8ListChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aUint8ListArg = args[1] as! FlutterStandardTypedData
        do {
          let result = try api.golubDelegate.echoUint8List(
            golubApi: api, golubInstance: golubInstanceArg, aUint8List: aUint8ListArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoUint8ListChannel.setMessageHandler(nil)
    }
    let echoObjectChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoObject",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoObjectChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let anObjectArg = args[1]!
        do {
          let result = try api.golubDelegate.echoObject(
            golubApi: api, golubInstance: golubInstanceArg, anObject: anObjectArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoObjectChannel.setMessageHandler(nil)
    }
    let echoListChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoList",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoListChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aListArg = args[1] as! [Any?]
        do {
          let result = try api.golubDelegate.echoList(
            golubApi: api, golubInstance: golubInstanceArg, aList: aListArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoListChannel.setMessageHandler(nil)
    }
    let echoProxyApiListChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoProxyApiList",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoProxyApiListChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aListArg = args[1] as! [ProxyApiTestClass]
        do {
          let result = try api.golubDelegate.echoProxyApiList(
            golubApi: api, golubInstance: golubInstanceArg, aList: aListArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoProxyApiListChannel.setMessageHandler(nil)
    }
    let echoMapChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoMap",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoMapChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aMapArg = args[1] as! [String?: Any?]
        do {
          let result = try api.golubDelegate.echoMap(
            golubApi: api, golubInstance: golubInstanceArg, aMap: aMapArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoMapChannel.setMessageHandler(nil)
    }
    let echoProxyApiMapChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoProxyApiMap",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoProxyApiMapChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aMapArg = args[1] as! [String: ProxyApiTestClass]
        do {
          let result = try api.golubDelegate.echoProxyApiMap(
            golubApi: api, golubInstance: golubInstanceArg, aMap: aMapArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoProxyApiMapChannel.setMessageHandler(nil)
    }
    let echoEnumChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoEnum",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoEnumChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let anEnumArg = args[1] as! ProxyApiTestEnum
        do {
          let result = try api.golubDelegate.echoEnum(
            golubApi: api, golubInstance: golubInstanceArg, anEnum: anEnumArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoEnumChannel.setMessageHandler(nil)
    }
    let echoProxyApiChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoProxyApi",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoProxyApiChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aProxyApiArg = args[1] as! ProxyApiSuperClass
        do {
          let result = try api.golubDelegate.echoProxyApi(
            golubApi: api, golubInstance: golubInstanceArg, aProxyApi: aProxyApiArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoProxyApiChannel.setMessageHandler(nil)
    }
    let echoNullableIntChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoNullableInt",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoNullableIntChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aNullableIntArg: Int64? = nilOrValue(args[1])
        do {
          let result = try api.golubDelegate.echoNullableInt(
            golubApi: api, golubInstance: golubInstanceArg, aNullableInt: aNullableIntArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoNullableIntChannel.setMessageHandler(nil)
    }
    let echoNullableDoubleChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoNullableDouble",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoNullableDoubleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aNullableDoubleArg: Double? = nilOrValue(args[1])
        do {
          let result = try api.golubDelegate.echoNullableDouble(
            golubApi: api, golubInstance: golubInstanceArg, aNullableDouble: aNullableDoubleArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoNullableDoubleChannel.setMessageHandler(nil)
    }
    let echoNullableBoolChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoNullableBool",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoNullableBoolChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aNullableBoolArg: Bool? = nilOrValue(args[1])
        do {
          let result = try api.golubDelegate.echoNullableBool(
            golubApi: api, golubInstance: golubInstanceArg, aNullableBool: aNullableBoolArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoNullableBoolChannel.setMessageHandler(nil)
    }
    let echoNullableStringChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoNullableString",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoNullableStringChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aNullableStringArg: String? = nilOrValue(args[1])
        do {
          let result = try api.golubDelegate.echoNullableString(
            golubApi: api, golubInstance: golubInstanceArg, aNullableString: aNullableStringArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoNullableStringChannel.setMessageHandler(nil)
    }
    let echoNullableUint8ListChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoNullableUint8List",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoNullableUint8ListChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aNullableUint8ListArg: FlutterStandardTypedData? = nilOrValue(args[1])
        do {
          let result = try api.golubDelegate.echoNullableUint8List(
            golubApi: api, golubInstance: golubInstanceArg,
            aNullableUint8List: aNullableUint8ListArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoNullableUint8ListChannel.setMessageHandler(nil)
    }
    let echoNullableObjectChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoNullableObject",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoNullableObjectChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aNullableObjectArg: Any? = args[1]
        do {
          let result = try api.golubDelegate.echoNullableObject(
            golubApi: api, golubInstance: golubInstanceArg, aNullableObject: aNullableObjectArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoNullableObjectChannel.setMessageHandler(nil)
    }
    let echoNullableListChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoNullableList",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoNullableListChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aNullableListArg: [Any?]? = nilOrValue(args[1])
        do {
          let result = try api.golubDelegate.echoNullableList(
            golubApi: api, golubInstance: golubInstanceArg, aNullableList: aNullableListArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoNullableListChannel.setMessageHandler(nil)
    }
    let echoNullableMapChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoNullableMap",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoNullableMapChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aNullableMapArg: [String?: Any?]? = nilOrValue(args[1])
        do {
          let result = try api.golubDelegate.echoNullableMap(
            golubApi: api, golubInstance: golubInstanceArg, aNullableMap: aNullableMapArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoNullableMapChannel.setMessageHandler(nil)
    }
    let echoNullableEnumChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoNullableEnum",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoNullableEnumChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aNullableEnumArg: ProxyApiTestEnum? = nilOrValue(args[1])
        do {
          let result = try api.golubDelegate.echoNullableEnum(
            golubApi: api, golubInstance: golubInstanceArg, aNullableEnum: aNullableEnumArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoNullableEnumChannel.setMessageHandler(nil)
    }
    let echoNullableProxyApiChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoNullableProxyApi",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoNullableProxyApiChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aNullableProxyApiArg: ProxyApiSuperClass? = nilOrValue(args[1])
        do {
          let result = try api.golubDelegate.echoNullableProxyApi(
            golubApi: api, golubInstance: golubInstanceArg, aNullableProxyApi: aNullableProxyApiArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoNullableProxyApiChannel.setMessageHandler(nil)
    }
    let noopAsyncChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.noopAsync",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      noopAsyncChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        api.golubDelegate.noopAsync(golubApi: api, golubInstance: golubInstanceArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      noopAsyncChannel.setMessageHandler(nil)
    }
    let echoAsyncIntChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncInt",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncIntChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let anIntArg = args[1] as! Int64
        api.golubDelegate.echoAsyncInt(
          golubApi: api, golubInstance: golubInstanceArg, anInt: anIntArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncIntChannel.setMessageHandler(nil)
    }
    let echoAsyncDoubleChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncDouble",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncDoubleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aDoubleArg = args[1] as! Double
        api.golubDelegate.echoAsyncDouble(
          golubApi: api, golubInstance: golubInstanceArg, aDouble: aDoubleArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncDoubleChannel.setMessageHandler(nil)
    }
    let echoAsyncBoolChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncBool",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncBoolChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aBoolArg = args[1] as! Bool
        api.golubDelegate.echoAsyncBool(
          golubApi: api, golubInstance: golubInstanceArg, aBool: aBoolArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncBoolChannel.setMessageHandler(nil)
    }
    let echoAsyncStringChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncString",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncStringChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aStringArg = args[1] as! String
        api.golubDelegate.echoAsyncString(
          golubApi: api, golubInstance: golubInstanceArg, aString: aStringArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncStringChannel.setMessageHandler(nil)
    }
    let echoAsyncUint8ListChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncUint8List",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncUint8ListChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aUint8ListArg = args[1] as! FlutterStandardTypedData
        api.golubDelegate.echoAsyncUint8List(
          golubApi: api, golubInstance: golubInstanceArg, aUint8List: aUint8ListArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncUint8ListChannel.setMessageHandler(nil)
    }
    let echoAsyncObjectChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncObject",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncObjectChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let anObjectArg = args[1]!
        api.golubDelegate.echoAsyncObject(
          golubApi: api, golubInstance: golubInstanceArg, anObject: anObjectArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncObjectChannel.setMessageHandler(nil)
    }
    let echoAsyncListChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncList",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncListChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aListArg = args[1] as! [Any?]
        api.golubDelegate.echoAsyncList(
          golubApi: api, golubInstance: golubInstanceArg, aList: aListArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncListChannel.setMessageHandler(nil)
    }
    let echoAsyncMapChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncMap",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncMapChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aMapArg = args[1] as! [String?: Any?]
        api.golubDelegate.echoAsyncMap(
          golubApi: api, golubInstance: golubInstanceArg, aMap: aMapArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncMapChannel.setMessageHandler(nil)
    }
    let echoAsyncEnumChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncEnum",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncEnumChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let anEnumArg = args[1] as! ProxyApiTestEnum
        api.golubDelegate.echoAsyncEnum(
          golubApi: api, golubInstance: golubInstanceArg, anEnum: anEnumArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncEnumChannel.setMessageHandler(nil)
    }
    let throwAsyncErrorChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.throwAsyncError",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      throwAsyncErrorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        api.golubDelegate.throwAsyncError(golubApi: api, golubInstance: golubInstanceArg) {
          result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      throwAsyncErrorChannel.setMessageHandler(nil)
    }
    let throwAsyncErrorFromVoidChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.throwAsyncErrorFromVoid",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      throwAsyncErrorFromVoidChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        api.golubDelegate.throwAsyncErrorFromVoid(golubApi: api, golubInstance: golubInstanceArg) {
          result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      throwAsyncErrorFromVoidChannel.setMessageHandler(nil)
    }
    let throwAsyncFlutterErrorChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.throwAsyncFlutterError",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      throwAsyncFlutterErrorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        api.golubDelegate.throwAsyncFlutterError(golubApi: api, golubInstance: golubInstanceArg) {
          result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      throwAsyncFlutterErrorChannel.setMessageHandler(nil)
    }
    let echoAsyncNullableIntChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncNullableInt",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncNullableIntChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let anIntArg: Int64? = nilOrValue(args[1])
        api.golubDelegate.echoAsyncNullableInt(
          golubApi: api, golubInstance: golubInstanceArg, anInt: anIntArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncNullableIntChannel.setMessageHandler(nil)
    }
    let echoAsyncNullableDoubleChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncNullableDouble",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncNullableDoubleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aDoubleArg: Double? = nilOrValue(args[1])
        api.golubDelegate.echoAsyncNullableDouble(
          golubApi: api, golubInstance: golubInstanceArg, aDouble: aDoubleArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncNullableDoubleChannel.setMessageHandler(nil)
    }
    let echoAsyncNullableBoolChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncNullableBool",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncNullableBoolChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aBoolArg: Bool? = nilOrValue(args[1])
        api.golubDelegate.echoAsyncNullableBool(
          golubApi: api, golubInstance: golubInstanceArg, aBool: aBoolArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncNullableBoolChannel.setMessageHandler(nil)
    }
    let echoAsyncNullableStringChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncNullableString",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncNullableStringChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aStringArg: String? = nilOrValue(args[1])
        api.golubDelegate.echoAsyncNullableString(
          golubApi: api, golubInstance: golubInstanceArg, aString: aStringArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncNullableStringChannel.setMessageHandler(nil)
    }
    let echoAsyncNullableUint8ListChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncNullableUint8List",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncNullableUint8ListChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aUint8ListArg: FlutterStandardTypedData? = nilOrValue(args[1])
        api.golubDelegate.echoAsyncNullableUint8List(
          golubApi: api, golubInstance: golubInstanceArg, aUint8List: aUint8ListArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncNullableUint8ListChannel.setMessageHandler(nil)
    }
    let echoAsyncNullableObjectChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncNullableObject",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncNullableObjectChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let anObjectArg: Any? = args[1]
        api.golubDelegate.echoAsyncNullableObject(
          golubApi: api, golubInstance: golubInstanceArg, anObject: anObjectArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncNullableObjectChannel.setMessageHandler(nil)
    }
    let echoAsyncNullableListChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncNullableList",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncNullableListChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aListArg: [Any?]? = nilOrValue(args[1])
        api.golubDelegate.echoAsyncNullableList(
          golubApi: api, golubInstance: golubInstanceArg, aList: aListArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncNullableListChannel.setMessageHandler(nil)
    }
    let echoAsyncNullableMapChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncNullableMap",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncNullableMapChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aMapArg: [String?: Any?]? = nilOrValue(args[1])
        api.golubDelegate.echoAsyncNullableMap(
          golubApi: api, golubInstance: golubInstanceArg, aMap: aMapArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncNullableMapChannel.setMessageHandler(nil)
    }
    let echoAsyncNullableEnumChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncNullableEnum",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoAsyncNullableEnumChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let anEnumArg: ProxyApiTestEnum? = nilOrValue(args[1])
        api.golubDelegate.echoAsyncNullableEnum(
          golubApi: api, golubInstance: golubInstanceArg, anEnum: anEnumArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      echoAsyncNullableEnumChannel.setMessageHandler(nil)
    }
    let staticNoopChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.staticNoop",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      staticNoopChannel.setMessageHandler { _, reply in
        do {
          try api.golubDelegate.staticNoop(golubApi: api)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      staticNoopChannel.setMessageHandler(nil)
    }
    let echoStaticStringChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoStaticString",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      echoStaticStringChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let aStringArg = args[0] as! String
        do {
          let result = try api.golubDelegate.echoStaticString(golubApi: api, aString: aStringArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      echoStaticStringChannel.setMessageHandler(nil)
    }
    let staticAsyncNoopChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.staticAsyncNoop",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      staticAsyncNoopChannel.setMessageHandler { _, reply in
        api.golubDelegate.staticAsyncNoop(golubApi: api) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      staticAsyncNoopChannel.setMessageHandler(nil)
    }
    let callFlutterNoopChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterNoop",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterNoopChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        api.golubDelegate.callFlutterNoop(golubApi: api, golubInstance: golubInstanceArg) {
          result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterNoopChannel.setMessageHandler(nil)
    }
    let callFlutterThrowErrorChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterThrowError",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterThrowErrorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        api.golubDelegate.callFlutterThrowError(golubApi: api, golubInstance: golubInstanceArg) {
          result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterThrowErrorChannel.setMessageHandler(nil)
    }
    let callFlutterThrowErrorFromVoidChannel = FlutterBasicMessageChannel(
      name:
        "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterThrowErrorFromVoid",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterThrowErrorFromVoidChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        api.golubDelegate.callFlutterThrowErrorFromVoid(
          golubApi: api, golubInstance: golubInstanceArg
        ) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterThrowErrorFromVoidChannel.setMessageHandler(nil)
    }
    let callFlutterEchoBoolChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoBool",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoBoolChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aBoolArg = args[1] as! Bool
        api.golubDelegate.callFlutterEchoBool(
          golubApi: api, golubInstance: golubInstanceArg, aBool: aBoolArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoBoolChannel.setMessageHandler(nil)
    }
    let callFlutterEchoIntChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoInt",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoIntChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let anIntArg = args[1] as! Int64
        api.golubDelegate.callFlutterEchoInt(
          golubApi: api, golubInstance: golubInstanceArg, anInt: anIntArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoIntChannel.setMessageHandler(nil)
    }
    let callFlutterEchoDoubleChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoDouble",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoDoubleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aDoubleArg = args[1] as! Double
        api.golubDelegate.callFlutterEchoDouble(
          golubApi: api, golubInstance: golubInstanceArg, aDouble: aDoubleArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoDoubleChannel.setMessageHandler(nil)
    }
    let callFlutterEchoStringChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoString",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoStringChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aStringArg = args[1] as! String
        api.golubDelegate.callFlutterEchoString(
          golubApi: api, golubInstance: golubInstanceArg, aString: aStringArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoStringChannel.setMessageHandler(nil)
    }
    let callFlutterEchoUint8ListChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoUint8List",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoUint8ListChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aUint8ListArg = args[1] as! FlutterStandardTypedData
        api.golubDelegate.callFlutterEchoUint8List(
          golubApi: api, golubInstance: golubInstanceArg, aUint8List: aUint8ListArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoUint8ListChannel.setMessageHandler(nil)
    }
    let callFlutterEchoListChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoList",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoListChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aListArg = args[1] as! [Any?]
        api.golubDelegate.callFlutterEchoList(
          golubApi: api, golubInstance: golubInstanceArg, aList: aListArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoListChannel.setMessageHandler(nil)
    }
    let callFlutterEchoProxyApiListChannel = FlutterBasicMessageChannel(
      name:
        "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoProxyApiList",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoProxyApiListChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aListArg = args[1] as! [ProxyApiTestClass?]
        api.golubDelegate.callFlutterEchoProxyApiList(
          golubApi: api, golubInstance: golubInstanceArg, aList: aListArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoProxyApiListChannel.setMessageHandler(nil)
    }
    let callFlutterEchoMapChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoMap",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoMapChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aMapArg = args[1] as! [String?: Any?]
        api.golubDelegate.callFlutterEchoMap(
          golubApi: api, golubInstance: golubInstanceArg, aMap: aMapArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoMapChannel.setMessageHandler(nil)
    }
    let callFlutterEchoProxyApiMapChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoProxyApiMap",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoProxyApiMapChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aMapArg = args[1] as! [String?: ProxyApiTestClass?]
        api.golubDelegate.callFlutterEchoProxyApiMap(
          golubApi: api, golubInstance: golubInstanceArg, aMap: aMapArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoProxyApiMapChannel.setMessageHandler(nil)
    }
    let callFlutterEchoEnumChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoEnum",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoEnumChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let anEnumArg = args[1] as! ProxyApiTestEnum
        api.golubDelegate.callFlutterEchoEnum(
          golubApi: api, golubInstance: golubInstanceArg, anEnum: anEnumArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoEnumChannel.setMessageHandler(nil)
    }
    let callFlutterEchoProxyApiChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoProxyApi",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoProxyApiChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aProxyApiArg = args[1] as! ProxyApiSuperClass
        api.golubDelegate.callFlutterEchoProxyApi(
          golubApi: api, golubInstance: golubInstanceArg, aProxyApi: aProxyApiArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoProxyApiChannel.setMessageHandler(nil)
    }
    let callFlutterEchoNullableBoolChannel = FlutterBasicMessageChannel(
      name:
        "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoNullableBool",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoNullableBoolChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aBoolArg: Bool? = nilOrValue(args[1])
        api.golubDelegate.callFlutterEchoNullableBool(
          golubApi: api, golubInstance: golubInstanceArg, aBool: aBoolArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoNullableBoolChannel.setMessageHandler(nil)
    }
    let callFlutterEchoNullableIntChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoNullableInt",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoNullableIntChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let anIntArg: Int64? = nilOrValue(args[1])
        api.golubDelegate.callFlutterEchoNullableInt(
          golubApi: api, golubInstance: golubInstanceArg, anInt: anIntArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoNullableIntChannel.setMessageHandler(nil)
    }
    let callFlutterEchoNullableDoubleChannel = FlutterBasicMessageChannel(
      name:
        "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoNullableDouble",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoNullableDoubleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aDoubleArg: Double? = nilOrValue(args[1])
        api.golubDelegate.callFlutterEchoNullableDouble(
          golubApi: api, golubInstance: golubInstanceArg, aDouble: aDoubleArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoNullableDoubleChannel.setMessageHandler(nil)
    }
    let callFlutterEchoNullableStringChannel = FlutterBasicMessageChannel(
      name:
        "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoNullableString",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoNullableStringChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aStringArg: String? = nilOrValue(args[1])
        api.golubDelegate.callFlutterEchoNullableString(
          golubApi: api, golubInstance: golubInstanceArg, aString: aStringArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoNullableStringChannel.setMessageHandler(nil)
    }
    let callFlutterEchoNullableUint8ListChannel = FlutterBasicMessageChannel(
      name:
        "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoNullableUint8List",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoNullableUint8ListChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aUint8ListArg: FlutterStandardTypedData? = nilOrValue(args[1])
        api.golubDelegate.callFlutterEchoNullableUint8List(
          golubApi: api, golubInstance: golubInstanceArg, aUint8List: aUint8ListArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoNullableUint8ListChannel.setMessageHandler(nil)
    }
    let callFlutterEchoNullableListChannel = FlutterBasicMessageChannel(
      name:
        "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoNullableList",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoNullableListChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aListArg: [Any?]? = nilOrValue(args[1])
        api.golubDelegate.callFlutterEchoNullableList(
          golubApi: api, golubInstance: golubInstanceArg, aList: aListArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoNullableListChannel.setMessageHandler(nil)
    }
    let callFlutterEchoNullableMapChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoNullableMap",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoNullableMapChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aMapArg: [String?: Any?]? = nilOrValue(args[1])
        api.golubDelegate.callFlutterEchoNullableMap(
          golubApi: api, golubInstance: golubInstanceArg, aMap: aMapArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoNullableMapChannel.setMessageHandler(nil)
    }
    let callFlutterEchoNullableEnumChannel = FlutterBasicMessageChannel(
      name:
        "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoNullableEnum",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoNullableEnumChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let anEnumArg: ProxyApiTestEnum? = nilOrValue(args[1])
        api.golubDelegate.callFlutterEchoNullableEnum(
          golubApi: api, golubInstance: golubInstanceArg, anEnum: anEnumArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoNullableEnumChannel.setMessageHandler(nil)
    }
    let callFlutterEchoNullableProxyApiChannel = FlutterBasicMessageChannel(
      name:
        "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoNullableProxyApi",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoNullableProxyApiChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aProxyApiArg: ProxyApiSuperClass? = nilOrValue(args[1])
        api.golubDelegate.callFlutterEchoNullableProxyApi(
          golubApi: api, golubInstance: golubInstanceArg, aProxyApi: aProxyApiArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoNullableProxyApiChannel.setMessageHandler(nil)
    }
    let callFlutterNoopAsyncChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterNoopAsync",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterNoopAsyncChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        api.golubDelegate.callFlutterNoopAsync(golubApi: api, golubInstance: golubInstanceArg) {
          result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterNoopAsyncChannel.setMessageHandler(nil)
    }
    let callFlutterEchoAsyncStringChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoAsyncString",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      callFlutterEchoAsyncStringChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiTestClass
        let aStringArg = args[1] as! String
        api.golubDelegate.callFlutterEchoAsyncString(
          golubApi: api, golubInstance: golubInstanceArg, aString: aStringArg
        ) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      callFlutterEchoAsyncStringChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of ProxyApiTestClass and attaches it to [golubInstance].
  public func golubNewInstance(
    golubInstance: ProxyApiTestClass,
    completion: @escaping (Result<Void, ProxyApiTestsError>) -> Void
  ) {
    if golubRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          ProxyApiTestsError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    } else if golubRegistrar.instanceManager.containsInstance(golubInstance as AnyObject) {
      completion(.success(()))
    } else {
      completion(
        .failure(
          ProxyApiTestsError(
            code: "new-instance-error",
            message:
              "Error: Attempting to create a new Dart instance of ProxyApiTestClass, but the class has a nonnull callback method.",
            details: "")))
    }
  }
  /// A no-op function taking no arguments and returning no value, to sanity
  /// test basic calling.
  func flutterNoop(
    golubInstance golubInstanceArg: ProxyApiTestClass,
    completion: @escaping (Result<Void, ProxyApiTestsError>) -> Void
  ) {
    if golubRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          ProxyApiTestsError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = golubRegistrar.binaryMessenger
    let codec = golubRegistrar.codec
    let channelName: String =
      "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterNoop"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([golubInstanceArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(ProxyApiTestsError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  /// Responds with an error from an async function returning a value.
  func flutterThrowError(
    golubInstance golubInstanceArg: ProxyApiTestClass,
    completion: @escaping (Result<Any?, ProxyApiTestsError>) -> Void
  ) {
    if golubRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          ProxyApiTestsError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = golubRegistrar.binaryMessenger
    let codec = golubRegistrar.codec
    let channelName: String =
      "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterThrowError"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([golubInstanceArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(ProxyApiTestsError(code: code, message: message, details: details)))
      } else {
        let result: Any? = listResponse[0]
        completion(.success(result))
      }
    }
  }

  /// Responds with an error from an async void function.
  func flutterThrowErrorFromVoid(
    golubInstance golubInstanceArg: ProxyApiTestClass,
    completion: @escaping (Result<Void, ProxyApiTestsError>) -> Void
  ) {
    if golubRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          ProxyApiTestsError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = golubRegistrar.binaryMessenger
    let codec = golubRegistrar.codec
    let channelName: String =
      "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterThrowErrorFromVoid"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([golubInstanceArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(ProxyApiTestsError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  /// Returns the passed boolean, to test serialization and deserialization.
  func flutterEchoBool(
    golubInstance golubInstanceArg: ProxyApiTestClass, aBool aBoolArg: Bool,
    completion: @escaping (Result<Bool, ProxyApiTestsError>) -> Void
  ) {
    if golubRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          ProxyApiTestsError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = golubRegistrar.binaryMessenger
    let codec = golubRegistrar.codec
    let channelName: String =
      "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoBool"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([golubInstanceArg, aBoolArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(ProxyApiTestsError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(
          .failure(
            ProxyApiTestsError(
              code: "null-error",
              message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! Bool
        completion(.success(result))
      }
    }
  }

  /// Returns the passed int, to test serialization and deserialization.
  func flutterEchoInt(
    golubInstance golubInstanceArg: ProxyApiTestClass, anInt anIntArg: Int64,
    completion: @escaping (Result<Int64, ProxyApiTestsError>) -> Void
  ) {
    if golubRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          ProxyApiTestsError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = golubRegistrar.binaryMessenger
    let codec = golubRegistrar.codec
    let channelName: String =
      "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoInt"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([golubInstanceArg, anIntArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(ProxyApiTestsError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(
          .failure(
            ProxyApiTestsError(
              code: "null-error",
              message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! Int64
        completion(.success(result))
      }
    }
  }

  /// Returns the passed double, to test serialization and deserialization.
  func flutterEchoDouble(
    golubInstance golubInstanceArg: ProxyApiTestClass, aDouble aDoubleArg: Double,
    completion: @escaping (Result<Double, ProxyApiTestsError>) -> Void
  ) {
    if golubRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          ProxyApiTestsError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = golubRegistrar.binaryMessenger
    let codec = golubRegistrar.codec
    let channelName: String =
      "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoDouble"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([golubInstanceArg, aDoubleArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(ProxyApiTestsError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(
          .failure(
            ProxyApiTestsError(
              code: "null-error",
              message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! Double
        completion(.success(result))
      }
    }
  }

  /// Returns the passed string, to test serialization and deserialization.
  func flutterEchoString(
    golubInstance golubInstanceArg: ProxyApiTestClass, aString aStringArg: String,
    completion: @escaping (Result<String, ProxyApiTestsError>) -> Void
  ) {
    if golubRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          ProxyApiTestsError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = golubRegistrar.binaryMessenger
    let codec = golubRegistrar.codec
    let channelName: String =
      "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoString"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([golubInstanceArg, aStringArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(ProxyApiTestsError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(
          .failure(
            ProxyApiTestsError(
              code: "null-error",
              message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! String
        completion(.success(result))
      }
    }
  }

  /// Returns the passed byte list, to test serialization and deserialization.
  func flutterEchoUint8List(
    golubInstance golubInstanceArg: ProxyApiTestClass, aList aListArg: FlutterStandardTypedData,
    completion: @escaping (Result<FlutterStandardTypedData, ProxyApiTestsError>) -> Void
  ) {
    if golubRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          ProxyApiTestsError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = golubRegistrar.binaryMessenger
    let codec = golubRegistrar.codec
    let channelName: String =
      "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoUint8List"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([golubInstanceArg, aListArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(ProxyApiTestsError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(
          .failure(
            ProxyApiTestsError(
              code: "null-error",
              message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! FlutterStandardTypedData
        completion(.success(result))
      }
    }
  }

  /// Returns the passed list, to test serialization and deserialization.
  func flutterEchoList(
    golubInstance golubInstanceArg: ProxyApiTestClass, aList aListArg: [Any?],
    completion: @escaping (Result<[Any?], ProxyApiTestsError>) -> Void
  ) {
    if golubRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          ProxyApiTestsError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = golubRegistrar.binaryMessenger
    let codec = golubRegistrar.codec
    let channelName: String =
      "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoList"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([golubInstanceArg, aListArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(ProxyApiTestsError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(
          .failure(
            ProxyApiTestsError(
              code: "null-error",
              message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! [Any?]
        completion(.success(result))
      }
    }
  }

  /// Returns the passed list with ProxyApis, to test serialization and
  /// deserialization.
  func flutterEchoProxyApiList(
    golubInstance golubInstanceArg: ProxyApiTestClass, aList aListArg: [ProxyApiTestClass?],
    completion: @escaping (Result<[ProxyApiTestClass?], ProxyApiTestsError>) -> Void
  ) {
    if golubRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          ProxyApiTestsError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = golubRegistrar.binaryMessenger
    let codec = golubRegistrar.codec
    let channelName: String =
      "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoProxyApiList"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([golubInstanceArg, aListArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(ProxyApiTestsError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(
          .failure(
            ProxyApiTestsError(
              code: "null-error",
              message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! [ProxyApiTestClass?]
        completion(.success(result))
      }
    }
  }

  /// Returns the passed map, to test serialization and deserialization.
  func flutterEchoMap(
    golubInstance golubInstanceArg: ProxyApiTestClass, aMap aMapArg: [String?: Any?],
    completion: @escaping (Result<[String?: Any?], ProxyApiTestsError>) -> Void
  ) {
    if golubRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          ProxyApiTestsError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = golubRegistrar.binaryMessenger
    let codec = golubRegistrar.codec
    let channelName: String =
      "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoMap"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([golubInstanceArg, aMapArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(ProxyApiTestsError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(
          .failure(
            ProxyApiTestsError(
              code: "null-error",
              message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! [String?: Any?]
        completion(.success(result))
      }
    }
  }

  /// Returns the passed map with ProxyApis, to test serialization and
  /// deserialization.
  func flutterEchoProxyApiMap(
    golubInstance golubInstanceArg: ProxyApiTestClass, aMap aMapArg: [String?: ProxyApiTestClass?],
    completion: @escaping (Result<[String?: ProxyApiTestClass?], ProxyApiTestsError>) -> Void
  ) {
    if golubRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          ProxyApiTestsError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = golubRegistrar.binaryMessenger
    let codec = golubRegistrar.codec
    let channelName: String =
      "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoProxyApiMap"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([golubInstanceArg, aMapArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(ProxyApiTestsError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(
          .failure(
            ProxyApiTestsError(
              code: "null-error",
              message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! [String?: ProxyApiTestClass?]
        completion(.success(result))
      }
    }
  }

  /// Returns the passed enum to test serialization and deserialization.
  func flutterEchoEnum(
    golubInstance golubInstanceArg: ProxyApiTestClass, anEnum anEnumArg: ProxyApiTestEnum,
    completion: @escaping (Result<ProxyApiTestEnum, ProxyApiTestsError>) -> Void
  ) {
    if golubRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          ProxyApiTestsError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = golubRegistrar.binaryMessenger
    let codec = golubRegistrar.codec
    let channelName: String =
      "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoEnum"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([golubInstanceArg, anEnumArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(ProxyApiTestsError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(
          .failure(
            ProxyApiTestsError(
              code: "null-error",
              message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! ProxyApiTestEnum
        completion(.success(result))
      }
    }
  }

  /// Returns the passed ProxyApi to test serialization and deserialization.
  func flutterEchoProxyApi(
    golubInstance golubInstanceArg: ProxyApiTestClass, aProxyApi aProxyApiArg: ProxyApiSuperClass,
    completion: @escaping (Result<ProxyApiSuperClass, ProxyApiTestsError>) -> Void
  ) {
    if golubRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          ProxyApiTestsError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = golubRegistrar.binaryMessenger
    let codec = golubRegistrar.codec
    let channelName: String =
      "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoProxyApi"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([golubInstanceArg, aProxyApiArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(ProxyApiTestsError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(
          .failure(
            ProxyApiTestsError(
              code: "null-error",
              message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! ProxyApiSuperClass
        completion(.success(result))
      }
    }
  }

  /// Returns the passed boolean, to test serialization and deserialization.
  func flutterEchoNullableBool(
    golubInstance golubInstanceArg: ProxyApiTestClass, aBool aBoolArg: Bool?,
    completion: @escaping (Result<Bool?, ProxyApiTestsError>) -> Void
  ) {
    if golubRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          ProxyApiTestsError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = golubRegistrar.binaryMessenger
    let codec = golubRegistrar.codec
    let channelName: String =
      "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableBool"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([golubInstanceArg, aBoolArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(ProxyApiTestsError(code: code, message: message, details: details)))
      } else {
        let result: Bool? = nilOrValue(listResponse[0])
        completion(.success(result))
      }
    }
  }

  /// Returns the passed int, to test serialization and deserialization.
  func flutterEchoNullableInt(
    golubInstance golubInstanceArg: ProxyApiTestClass, anInt anIntArg: Int64?,
    completion: @escaping (Result<Int64?, ProxyApiTestsError>) -> Void
  ) {
    if golubRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          ProxyApiTestsError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = golubRegistrar.binaryMessenger
    let codec = golubRegistrar.codec
    let channelName: String =
      "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableInt"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([golubInstanceArg, anIntArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(ProxyApiTestsError(code: code, message: message, details: details)))
      } else {
        let result: Int64? = nilOrValue(listResponse[0])
        completion(.success(result))
      }
    }
  }

  /// Returns the passed double, to test serialization and deserialization.
  func flutterEchoNullableDouble(
    golubInstance golubInstanceArg: ProxyApiTestClass, aDouble aDoubleArg: Double?,
    completion: @escaping (Result<Double?, ProxyApiTestsError>) -> Void
  ) {
    if golubRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          ProxyApiTestsError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = golubRegistrar.binaryMessenger
    let codec = golubRegistrar.codec
    let channelName: String =
      "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableDouble"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([golubInstanceArg, aDoubleArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(ProxyApiTestsError(code: code, message: message, details: details)))
      } else {
        let result: Double? = nilOrValue(listResponse[0])
        completion(.success(result))
      }
    }
  }

  /// Returns the passed string, to test serialization and deserialization.
  func flutterEchoNullableString(
    golubInstance golubInstanceArg: ProxyApiTestClass, aString aStringArg: String?,
    completion: @escaping (Result<String?, ProxyApiTestsError>) -> Void
  ) {
    if golubRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          ProxyApiTestsError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = golubRegistrar.binaryMessenger
    let codec = golubRegistrar.codec
    let channelName: String =
      "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableString"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([golubInstanceArg, aStringArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(ProxyApiTestsError(code: code, message: message, details: details)))
      } else {
        let result: String? = nilOrValue(listResponse[0])
        completion(.success(result))
      }
    }
  }

  /// Returns the passed byte list, to test serialization and deserialization.
  func flutterEchoNullableUint8List(
    golubInstance golubInstanceArg: ProxyApiTestClass, aList aListArg: FlutterStandardTypedData?,
    completion: @escaping (Result<FlutterStandardTypedData?, ProxyApiTestsError>) -> Void
  ) {
    if golubRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          ProxyApiTestsError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = golubRegistrar.binaryMessenger
    let codec = golubRegistrar.codec
    let channelName: String =
      "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableUint8List"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([golubInstanceArg, aListArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(ProxyApiTestsError(code: code, message: message, details: details)))
      } else {
        let result: FlutterStandardTypedData? = nilOrValue(listResponse[0])
        completion(.success(result))
      }
    }
  }

  /// Returns the passed list, to test serialization and deserialization.
  func flutterEchoNullableList(
    golubInstance golubInstanceArg: ProxyApiTestClass, aList aListArg: [Any?]?,
    completion: @escaping (Result<[Any?]?, ProxyApiTestsError>) -> Void
  ) {
    if golubRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          ProxyApiTestsError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = golubRegistrar.binaryMessenger
    let codec = golubRegistrar.codec
    let channelName: String =
      "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableList"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([golubInstanceArg, aListArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(ProxyApiTestsError(code: code, message: message, details: details)))
      } else {
        let result: [Any?]? = nilOrValue(listResponse[0])
        completion(.success(result))
      }
    }
  }

  /// Returns the passed map, to test serialization and deserialization.
  func flutterEchoNullableMap(
    golubInstance golubInstanceArg: ProxyApiTestClass, aMap aMapArg: [String?: Any?]?,
    completion: @escaping (Result<[String?: Any?]?, ProxyApiTestsError>) -> Void
  ) {
    if golubRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          ProxyApiTestsError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = golubRegistrar.binaryMessenger
    let codec = golubRegistrar.codec
    let channelName: String =
      "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableMap"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([golubInstanceArg, aMapArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(ProxyApiTestsError(code: code, message: message, details: details)))
      } else {
        let result: [String?: Any?]? = nilOrValue(listResponse[0])
        completion(.success(result))
      }
    }
  }

  /// Returns the passed enum to test serialization and deserialization.
  func flutterEchoNullableEnum(
    golubInstance golubInstanceArg: ProxyApiTestClass, anEnum anEnumArg: ProxyApiTestEnum?,
    completion: @escaping (Result<ProxyApiTestEnum?, ProxyApiTestsError>) -> Void
  ) {
    if golubRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          ProxyApiTestsError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = golubRegistrar.binaryMessenger
    let codec = golubRegistrar.codec
    let channelName: String =
      "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableEnum"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([golubInstanceArg, anEnumArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(ProxyApiTestsError(code: code, message: message, details: details)))
      } else {
        let result: ProxyApiTestEnum? = nilOrValue(listResponse[0])
        completion(.success(result))
      }
    }
  }

  /// Returns the passed ProxyApi to test serialization and deserialization.
  func flutterEchoNullableProxyApi(
    golubInstance golubInstanceArg: ProxyApiTestClass, aProxyApi aProxyApiArg: ProxyApiSuperClass?,
    completion: @escaping (Result<ProxyApiSuperClass?, ProxyApiTestsError>) -> Void
  ) {
    if golubRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          ProxyApiTestsError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = golubRegistrar.binaryMessenger
    let codec = golubRegistrar.codec
    let channelName: String =
      "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableProxyApi"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([golubInstanceArg, aProxyApiArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(ProxyApiTestsError(code: code, message: message, details: details)))
      } else {
        let result: ProxyApiSuperClass? = nilOrValue(listResponse[0])
        completion(.success(result))
      }
    }
  }

  /// A no-op function taking no arguments and returning no value, to sanity
  /// test basic asynchronous calling.
  func flutterNoopAsync(
    golubInstance golubInstanceArg: ProxyApiTestClass,
    completion: @escaping (Result<Void, ProxyApiTestsError>) -> Void
  ) {
    if golubRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          ProxyApiTestsError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = golubRegistrar.binaryMessenger
    let codec = golubRegistrar.codec
    let channelName: String =
      "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterNoopAsync"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([golubInstanceArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(ProxyApiTestsError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

  /// Returns the passed in generic Object asynchronously.
  func flutterEchoAsyncString(
    golubInstance golubInstanceArg: ProxyApiTestClass, aString aStringArg: String,
    completion: @escaping (Result<String, ProxyApiTestsError>) -> Void
  ) {
    if golubRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          ProxyApiTestsError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = golubRegistrar.binaryMessenger
    let codec = golubRegistrar.codec
    let channelName: String =
      "dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoAsyncString"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([golubInstanceArg, aStringArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(ProxyApiTestsError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(
          .failure(
            ProxyApiTestsError(
              code: "null-error",
              message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! String
        completion(.success(result))
      }
    }
  }

}
protocol GolubApiDelegateProxyApiSuperClass {
  func golubDefaultConstructor(golubApi: GolubApiProxyApiSuperClass) throws -> ProxyApiSuperClass
  func aSuperMethod(golubApi: GolubApiProxyApiSuperClass, golubInstance: ProxyApiSuperClass) throws
}

protocol GolubApiProtocolProxyApiSuperClass {
}

final class GolubApiProxyApiSuperClass: GolubApiProtocolProxyApiSuperClass {
  unowned let golubRegistrar: ProxyApiTestsGolubProxyApiRegistrar
  let golubDelegate: GolubApiDelegateProxyApiSuperClass
  init(
    golubRegistrar: ProxyApiTestsGolubProxyApiRegistrar,
    delegate: GolubApiDelegateProxyApiSuperClass
  ) {
    self.golubRegistrar = golubRegistrar
    self.golubDelegate = delegate
  }
  static func setUpMessageHandlers(
    binaryMessenger: FlutterBinaryMessenger, api: GolubApiProxyApiSuperClass?
  ) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: ProxyApiTestsGolubInternalProxyApiCodecReaderWriter(
          golubRegistrar: api!.golubRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let golubDefaultConstructorChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiSuperClass.golub_defaultConstructor",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      golubDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubIdentifierArg = args[0] as! Int64
        do {
          api.golubRegistrar.instanceManager.addDartCreatedInstance(
            try api.golubDelegate.golubDefaultConstructor(golubApi: api),
            withIdentifier: golubIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      golubDefaultConstructorChannel.setMessageHandler(nil)
    }
    let aSuperMethodChannel = FlutterBasicMessageChannel(
      name: "dev.bayori.golub.golub_integration_tests.ProxyApiSuperClass.aSuperMethod",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      aSuperMethodChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let golubInstanceArg = args[0] as! ProxyApiSuperClass
        do {
          try api.golubDelegate.aSuperMethod(golubApi: api, golubInstance: golubInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      aSuperMethodChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of ProxyApiSuperClass and attaches it to [golubInstance].
  public func golubNewInstance(
    golubInstance: ProxyApiSuperClass,
    completion: @escaping (Result<Void, ProxyApiTestsError>) -> Void
  ) {
    if golubRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          ProxyApiTestsError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    } else if golubRegistrar.instanceManager.containsInstance(golubInstance as AnyObject) {
      completion(.success(()))
    } else {
      let golubIdentifierArg = golubRegistrar.instanceManager.addHostCreatedInstance(
        golubInstance as AnyObject)
      let binaryMessenger = golubRegistrar.binaryMessenger
      let codec = golubRegistrar.codec
      let channelName: String =
        "dev.bayori.golub.golub_integration_tests.ProxyApiSuperClass.golub_newInstance"
      let channel = FlutterBasicMessageChannel(
        name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([golubIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(ProxyApiTestsError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
open class GolubApiDelegateProxyApiInterface {
}

protocol GolubApiProtocolProxyApiInterface {
  func anInterfaceMethod(
    golubInstance golubInstanceArg: ProxyApiInterface,
    completion: @escaping (Result<Void, ProxyApiTestsError>) -> Void)
}

final class GolubApiProxyApiInterface: GolubApiProtocolProxyApiInterface {
  unowned let golubRegistrar: ProxyApiTestsGolubProxyApiRegistrar
  let golubDelegate: GolubApiDelegateProxyApiInterface
  init(
    golubRegistrar: ProxyApiTestsGolubProxyApiRegistrar, delegate: GolubApiDelegateProxyApiInterface
  ) {
    self.golubRegistrar = golubRegistrar
    self.golubDelegate = delegate
  }
  ///Creates a Dart instance of ProxyApiInterface and attaches it to [golubInstance].
  public func golubNewInstance(
    golubInstance: ProxyApiInterface,
    completion: @escaping (Result<Void, ProxyApiTestsError>) -> Void
  ) {
    if golubRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          ProxyApiTestsError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    } else if golubRegistrar.instanceManager.containsInstance(golubInstance as AnyObject) {
      completion(.success(()))
    } else {
      let golubIdentifierArg = golubRegistrar.instanceManager.addHostCreatedInstance(
        golubInstance as AnyObject)
      let binaryMessenger = golubRegistrar.binaryMessenger
      let codec = golubRegistrar.codec
      let channelName: String =
        "dev.bayori.golub.golub_integration_tests.ProxyApiInterface.golub_newInstance"
      let channel = FlutterBasicMessageChannel(
        name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([golubIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(ProxyApiTestsError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
  func anInterfaceMethod(
    golubInstance golubInstanceArg: ProxyApiInterface,
    completion: @escaping (Result<Void, ProxyApiTestsError>) -> Void
  ) {
    if golubRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          ProxyApiTestsError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = golubRegistrar.binaryMessenger
    let codec = golubRegistrar.codec
    let channelName: String =
      "dev.bayori.golub.golub_integration_tests.ProxyApiInterface.anInterfaceMethod"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([golubInstanceArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(ProxyApiTestsError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }

}
protocol GolubApiDelegateClassWithApiRequirement {
  @available(iOS 15.0.0, macOS 10.0.0, *)
  func golubDefaultConstructor(golubApi: GolubApiClassWithApiRequirement) throws
    -> ClassWithApiRequirement
  @available(iOS 15.0.0, macOS 10.0.0, *)
  func aMethod(golubApi: GolubApiClassWithApiRequirement, golubInstance: ClassWithApiRequirement)
    throws
}

protocol GolubApiProtocolClassWithApiRequirement {
}

final class GolubApiClassWithApiRequirement: GolubApiProtocolClassWithApiRequirement {
  unowned let golubRegistrar: ProxyApiTestsGolubProxyApiRegistrar
  let golubDelegate: GolubApiDelegateClassWithApiRequirement
  init(
    golubRegistrar: ProxyApiTestsGolubProxyApiRegistrar,
    delegate: GolubApiDelegateClassWithApiRequirement
  ) {
    self.golubRegistrar = golubRegistrar
    self.golubDelegate = delegate
  }
  static func setUpMessageHandlers(
    binaryMessenger: FlutterBinaryMessenger, api: GolubApiClassWithApiRequirement?
  ) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: ProxyApiTestsGolubInternalProxyApiCodecReaderWriter(
          golubRegistrar: api!.golubRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    if #available(iOS 15.0.0, macOS 10.0.0, *) {
      let golubDefaultConstructorChannel = FlutterBasicMessageChannel(
        name:
          "dev.bayori.golub.golub_integration_tests.ClassWithApiRequirement.golub_defaultConstructor",
        binaryMessenger: binaryMessenger, codec: codec)
      if let api = api {
        golubDefaultConstructorChannel.setMessageHandler { message, reply in
          let args = message as! [Any?]
          let golubIdentifierArg = args[0] as! Int64
          do {
            api.golubRegistrar.instanceManager.addDartCreatedInstance(
              try api.golubDelegate.golubDefaultConstructor(golubApi: api),
              withIdentifier: golubIdentifierArg)
            reply(wrapResult(nil))
          } catch {
            reply(wrapError(error))
          }
        }
      } else {
        golubDefaultConstructorChannel.setMessageHandler(nil)
      }
    } else {
      let golubDefaultConstructorChannel = FlutterBasicMessageChannel(
        name:
          "dev.bayori.golub.golub_integration_tests.ClassWithApiRequirement.golub_defaultConstructor",
        binaryMessenger: binaryMessenger, codec: codec)
      if api != nil {
        golubDefaultConstructorChannel.setMessageHandler { message, reply in
          reply(
            wrapError(
              FlutterError(
                code: "GolubUnsupportedOperationError",
                message:
                  "Call to golubDefaultConstructor requires @available(iOS 15.0.0, macOS 10.0.0, *).",
                details: nil
              )))
        }
      } else {
        golubDefaultConstructorChannel.setMessageHandler(nil)
      }
    }
    if #available(iOS 15.0.0, macOS 10.0.0, *) {
      let aMethodChannel = FlutterBasicMessageChannel(
        name: "dev.bayori.golub.golub_integration_tests.ClassWithApiRequirement.aMethod",
        binaryMessenger: binaryMessenger, codec: codec)
      if let api = api {
        aMethodChannel.setMessageHandler { message, reply in
          let args = message as! [Any?]
          let golubInstanceArg = args[0] as! ClassWithApiRequirement
          do {
            try api.golubDelegate.aMethod(golubApi: api, golubInstance: golubInstanceArg)
            reply(wrapResult(nil))
          } catch {
            reply(wrapError(error))
          }
        }
      } else {
        aMethodChannel.setMessageHandler(nil)
      }
    } else {
      let aMethodChannel = FlutterBasicMessageChannel(
        name: "dev.bayori.golub.golub_integration_tests.ClassWithApiRequirement.aMethod",
        binaryMessenger: binaryMessenger, codec: codec)
      if api != nil {
        aMethodChannel.setMessageHandler { message, reply in
          reply(
            wrapError(
              FlutterError(
                code: "GolubUnsupportedOperationError",
                message: "Call to aMethod requires @available(iOS 15.0.0, macOS 10.0.0, *).",
                details: nil
              )))
        }
      } else {
        aMethodChannel.setMessageHandler(nil)
      }
    }
  }

  ///Creates a Dart instance of ClassWithApiRequirement and attaches it to [golubInstance].
  @available(iOS 15.0.0, macOS 10.0.0, *)
  public func golubNewInstance(
    golubInstance: ClassWithApiRequirement,
    completion: @escaping (Result<Void, ProxyApiTestsError>) -> Void
  ) {
    if golubRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          ProxyApiTestsError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
    } else if golubRegistrar.instanceManager.containsInstance(golubInstance as AnyObject) {
      completion(.success(()))
    } else {
      let golubIdentifierArg = golubRegistrar.instanceManager.addHostCreatedInstance(
        golubInstance as AnyObject)
      let binaryMessenger = golubRegistrar.binaryMessenger
      let codec = golubRegistrar.codec
      let channelName: String =
        "dev.bayori.golub.golub_integration_tests.ClassWithApiRequirement.golub_newInstance"
      let channel = FlutterBasicMessageChannel(
        name: channelName, binaryMessenger: binaryMessenger, codec: codec)
      channel.sendMessage([golubIdentifierArg] as [Any?]) { response in
        guard let listResponse = response as? [Any?] else {
          completion(.failure(createConnectionError(withChannelName: channelName)))
          return
        }
        if listResponse.count > 1 {
          let code: String = listResponse[0] as! String
          let message: String? = nilOrValue(listResponse[1])
          let details: String? = nilOrValue(listResponse[2])
          completion(.failure(ProxyApiTestsError(code: code, message: message, details: details)))
        } else {
          completion(.success(()))
        }
      }
    }
  }
}
