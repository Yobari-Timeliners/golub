// Copyright 2013 The Flutter Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// Autogenerated from Golub, do not edit directly.
// See also: https://pub.dev/packages/golub
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import, no_leading_underscores_for_local_identifiers

import 'dart:async';
import 'dart:io' show Platform;
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart'
    show ReadBuffer, WriteBuffer, immutable, protected, visibleForTesting;
import 'package:flutter/services.dart';
import 'package:flutter/widgets.dart' show WidgetsFlutterBinding;

PlatformException _createConnectionError(String channelName) {
  return PlatformException(
    code: 'channel-error',
    message: 'Unable to establish connection on channel: "$channelName".',
  );
}

List<Object?> wrapResponse({
  Object? result,
  PlatformException? error,
  bool empty = false,
}) {
  if (empty) {
    return <Object?>[];
  }
  if (error == null) {
    return <Object?>[result];
  }
  return <Object?>[error.code, error.message, error.details];
}

/// Provides overrides for the constructors and static members of each
/// Dart proxy class.
///
/// This is only intended to be used with unit tests to prevent errors from
/// making message calls in a unit test.
///
/// See [GolubOverrides.golub_reset] to set all overrides back to null.
@visibleForTesting
class GolubOverrides {
  /// Overrides [ProxyApiTestClass.new].
  static ProxyApiTestClass Function({
    required bool aBool,
    required int anInt,
    required double aDouble,
    required String aString,
    required Uint8List aUint8List,
    required List<Object?> aList,
    required Map<String?, Object?> aMap,
    required ProxyApiTestEnum anEnum,
    required ProxyApiSuperClass aProxyApi,
    required bool Function(
      ProxyApiTestClass golub_instance,
      bool aBool,
    )
    flutterEchoBool,
    required int Function(
      ProxyApiTestClass golub_instance,
      int anInt,
    )
    flutterEchoInt,
    required double Function(
      ProxyApiTestClass golub_instance,
      double aDouble,
    )
    flutterEchoDouble,
    required String Function(
      ProxyApiTestClass golub_instance,
      String aString,
    )
    flutterEchoString,
    required Uint8List Function(
      ProxyApiTestClass golub_instance,
      Uint8List aList,
    )
    flutterEchoUint8List,
    required List<Object?> Function(
      ProxyApiTestClass golub_instance,
      List<Object?> aList,
    )
    flutterEchoList,
    required List<ProxyApiTestClass?> Function(
      ProxyApiTestClass golub_instance,
      List<ProxyApiTestClass?> aList,
    )
    flutterEchoProxyApiList,
    required Map<String?, Object?> Function(
      ProxyApiTestClass golub_instance,
      Map<String?, Object?> aMap,
    )
    flutterEchoMap,
    required Map<String?, ProxyApiTestClass?> Function(
      ProxyApiTestClass golub_instance,
      Map<String?, ProxyApiTestClass?> aMap,
    )
    flutterEchoProxyApiMap,
    required ProxyApiTestEnum Function(
      ProxyApiTestClass golub_instance,
      ProxyApiTestEnum anEnum,
    )
    flutterEchoEnum,
    required ProxyApiSuperClass Function(
      ProxyApiTestClass golub_instance,
      ProxyApiSuperClass aProxyApi,
    )
    flutterEchoProxyApi,
    required Future<String> Function(
      ProxyApiTestClass golub_instance,
      String aString,
    )
    flutterEchoAsyncString,
    required bool boolParam,
    required int intParam,
    required double doubleParam,
    required String stringParam,
    required Uint8List aUint8ListParam,
    required List<Object?> listParam,
    required Map<String?, Object?> mapParam,
    required ProxyApiTestEnum enumParam,
    required ProxyApiSuperClass proxyApiParam,
    bool? aNullableBool,
    int? aNullableInt,
    double? aNullableDouble,
    String? aNullableString,
    Uint8List? aNullableUint8List,
    List<Object?>? aNullableList,
    Map<String?, Object?>? aNullableMap,
    ProxyApiTestEnum? aNullableEnum,
    ProxyApiSuperClass? aNullableProxyApi,
    void Function(ProxyApiInterface golub_instance)? anInterfaceMethod,
    void Function(ProxyApiTestClass golub_instance)? flutterNoop,
    Object? Function(ProxyApiTestClass golub_instance)? flutterThrowError,
    void Function(ProxyApiTestClass golub_instance)? flutterThrowErrorFromVoid,
    bool? Function(
      ProxyApiTestClass golub_instance,
      bool? aBool,
    )?
    flutterEchoNullableBool,
    int? Function(
      ProxyApiTestClass golub_instance,
      int? anInt,
    )?
    flutterEchoNullableInt,
    double? Function(
      ProxyApiTestClass golub_instance,
      double? aDouble,
    )?
    flutterEchoNullableDouble,
    String? Function(
      ProxyApiTestClass golub_instance,
      String? aString,
    )?
    flutterEchoNullableString,
    Uint8List? Function(
      ProxyApiTestClass golub_instance,
      Uint8List? aList,
    )?
    flutterEchoNullableUint8List,
    List<Object?>? Function(
      ProxyApiTestClass golub_instance,
      List<Object?>? aList,
    )?
    flutterEchoNullableList,
    Map<String?, Object?>? Function(
      ProxyApiTestClass golub_instance,
      Map<String?, Object?>? aMap,
    )?
    flutterEchoNullableMap,
    ProxyApiTestEnum? Function(
      ProxyApiTestClass golub_instance,
      ProxyApiTestEnum? anEnum,
    )?
    flutterEchoNullableEnum,
    ProxyApiSuperClass? Function(
      ProxyApiTestClass golub_instance,
      ProxyApiSuperClass? aProxyApi,
    )?
    flutterEchoNullableProxyApi,
    Future<void> Function(ProxyApiTestClass golub_instance)? flutterNoopAsync,
    bool? nullableBoolParam,
    int? nullableIntParam,
    double? nullableDoubleParam,
    String? nullableStringParam,
    Uint8List? nullableUint8ListParam,
    List<Object?>? nullableListParam,
    Map<String?, Object?>? nullableMapParam,
    ProxyApiTestEnum? nullableEnumParam,
    ProxyApiSuperClass? nullableProxyApiParam,
  })?
  proxyApiTestClass_new;

  /// Overrides [ProxyApiTestClass.namedConstructor].
  static ProxyApiTestClass Function({
    required bool aBool,
    required int anInt,
    required double aDouble,
    required String aString,
    required Uint8List aUint8List,
    required List<Object?> aList,
    required Map<String?, Object?> aMap,
    required ProxyApiTestEnum anEnum,
    required ProxyApiSuperClass aProxyApi,
    required bool Function(
      ProxyApiTestClass golub_instance,
      bool aBool,
    )
    flutterEchoBool,
    required int Function(
      ProxyApiTestClass golub_instance,
      int anInt,
    )
    flutterEchoInt,
    required double Function(
      ProxyApiTestClass golub_instance,
      double aDouble,
    )
    flutterEchoDouble,
    required String Function(
      ProxyApiTestClass golub_instance,
      String aString,
    )
    flutterEchoString,
    required Uint8List Function(
      ProxyApiTestClass golub_instance,
      Uint8List aList,
    )
    flutterEchoUint8List,
    required List<Object?> Function(
      ProxyApiTestClass golub_instance,
      List<Object?> aList,
    )
    flutterEchoList,
    required List<ProxyApiTestClass?> Function(
      ProxyApiTestClass golub_instance,
      List<ProxyApiTestClass?> aList,
    )
    flutterEchoProxyApiList,
    required Map<String?, Object?> Function(
      ProxyApiTestClass golub_instance,
      Map<String?, Object?> aMap,
    )
    flutterEchoMap,
    required Map<String?, ProxyApiTestClass?> Function(
      ProxyApiTestClass golub_instance,
      Map<String?, ProxyApiTestClass?> aMap,
    )
    flutterEchoProxyApiMap,
    required ProxyApiTestEnum Function(
      ProxyApiTestClass golub_instance,
      ProxyApiTestEnum anEnum,
    )
    flutterEchoEnum,
    required ProxyApiSuperClass Function(
      ProxyApiTestClass golub_instance,
      ProxyApiSuperClass aProxyApi,
    )
    flutterEchoProxyApi,
    required Future<String> Function(
      ProxyApiTestClass golub_instance,
      String aString,
    )
    flutterEchoAsyncString,
    bool? aNullableBool,
    int? aNullableInt,
    double? aNullableDouble,
    String? aNullableString,
    Uint8List? aNullableUint8List,
    List<Object?>? aNullableList,
    Map<String?, Object?>? aNullableMap,
    ProxyApiTestEnum? aNullableEnum,
    ProxyApiSuperClass? aNullableProxyApi,
    void Function(ProxyApiInterface golub_instance)? anInterfaceMethod,
    void Function(ProxyApiTestClass golub_instance)? flutterNoop,
    Object? Function(ProxyApiTestClass golub_instance)? flutterThrowError,
    void Function(ProxyApiTestClass golub_instance)? flutterThrowErrorFromVoid,
    bool? Function(
      ProxyApiTestClass golub_instance,
      bool? aBool,
    )?
    flutterEchoNullableBool,
    int? Function(
      ProxyApiTestClass golub_instance,
      int? anInt,
    )?
    flutterEchoNullableInt,
    double? Function(
      ProxyApiTestClass golub_instance,
      double? aDouble,
    )?
    flutterEchoNullableDouble,
    String? Function(
      ProxyApiTestClass golub_instance,
      String? aString,
    )?
    flutterEchoNullableString,
    Uint8List? Function(
      ProxyApiTestClass golub_instance,
      Uint8List? aList,
    )?
    flutterEchoNullableUint8List,
    List<Object?>? Function(
      ProxyApiTestClass golub_instance,
      List<Object?>? aList,
    )?
    flutterEchoNullableList,
    Map<String?, Object?>? Function(
      ProxyApiTestClass golub_instance,
      Map<String?, Object?>? aMap,
    )?
    flutterEchoNullableMap,
    ProxyApiTestEnum? Function(
      ProxyApiTestClass golub_instance,
      ProxyApiTestEnum? anEnum,
    )?
    flutterEchoNullableEnum,
    ProxyApiSuperClass? Function(
      ProxyApiTestClass golub_instance,
      ProxyApiSuperClass? aProxyApi,
    )?
    flutterEchoNullableProxyApi,
    Future<void> Function(ProxyApiTestClass golub_instance)? flutterNoopAsync,
  })?
  proxyApiTestClass_namedConstructor;

  /// Overrides [ProxyApiSuperClass.new].
  static ProxyApiSuperClass Function()? proxyApiSuperClass_new;

  /// Overrides [ClassWithApiRequirement.new].
  static ClassWithApiRequirement Function()? classWithApiRequirement_new;

  /// Overrides [ProxyApiTestClass.staticAttachedField].
  static ProxyApiSuperClass? proxyApiTestClass_staticAttachedField;

  /// Overrides [ProxyApiTestClass.staticNoop].
  static Future<void> Function()? proxyApiTestClass_staticNoop;

  /// Overrides [ProxyApiTestClass.echoStaticString].
  static Future<String> Function(String)? proxyApiTestClass_echoStaticString;

  /// Overrides [ProxyApiTestClass.staticAsyncNoop].
  static Future<void> Function()? proxyApiTestClass_staticAsyncNoop;

  /// Sets all overridden ProxyApi class members to null.
  static void golub_reset() {
    proxyApiTestClass_new = null;
    proxyApiTestClass_namedConstructor = null;
    proxyApiTestClass_staticAttachedField = null;
    proxyApiTestClass_staticNoop = null;
    proxyApiTestClass_echoStaticString = null;
    proxyApiTestClass_staticAsyncNoop = null;
    proxyApiSuperClass_new = null;
    classWithApiRequirement_new = null;
  }
}

/// An immutable object that serves as the base class for all Dart proxy classes
/// and can provide functional copies of itself.
///
/// All implementers are expected to be [immutable] as defined by the annotation
/// and override [golub_copy] returning an instance of itself.
@immutable
abstract class GolubInternalProxyApiBaseClass {
  /// Construct a [GolubInternalProxyApiBaseClass].
  GolubInternalProxyApiBaseClass({
    this.golub_binaryMessenger,
    GolubInstanceManager? golub_instanceManager,
  }) : golub_instanceManager =
           golub_instanceManager ?? GolubInstanceManager.instance;

  /// Sends and receives binary data across the Flutter platform barrier.
  ///
  /// If it is null, the default BinaryMessenger will be used, which routes to
  /// the host platform.
  @protected
  final BinaryMessenger? golub_binaryMessenger;

  /// Maintains instances stored to communicate with native language objects.
  final GolubInstanceManager golub_instanceManager;

  /// Instantiates and returns a functionally identical object to oneself.
  ///
  /// Outside of tests, this method should only ever be called by
  /// [GolubInstanceManager].
  ///
  /// Subclasses should always override their parent's implementation of this
  /// method.
  @protected
  GolubInternalProxyApiBaseClass golub_copy();
}

/// Maintains instances used to communicate with the native objects they
/// represent.
///
/// Added instances are stored as weak references and their copies are stored
/// as strong references to maintain access to their variables and callback
/// methods. Both are stored with the same identifier.
///
/// When a weak referenced instance becomes inaccessible,
/// [onWeakReferenceRemoved] is called with its associated identifier.
///
/// If an instance is retrieved and has the possibility to be used,
/// (e.g. calling [getInstanceWithWeakReference]) a copy of the strong reference
/// is added as a weak reference with the same identifier. This prevents a
/// scenario where the weak referenced instance was released and then later
/// returned by the host platform.
class GolubInstanceManager {
  /// Constructs a [GolubInstanceManager].
  GolubInstanceManager({required void Function(int) onWeakReferenceRemoved}) {
    this.onWeakReferenceRemoved = (int identifier) {
      _weakInstances.remove(identifier);
      onWeakReferenceRemoved(identifier);
    };
    _finalizer = Finalizer<int>(this.onWeakReferenceRemoved);
  }

  // Identifiers are locked to a specific range to avoid collisions with objects
  // created simultaneously by the host platform.
  // Host uses identifiers >= 2^16 and Dart is expected to use values n where,
  // 0 <= n < 2^16.
  static const int _maxDartCreatedIdentifier = 65536;

  /// The default [GolubInstanceManager] used by Dart proxy classes.
  ///
  /// On creation, this manager makes a call to clear the native
  /// InstanceManager. This is to prevent identifier conflicts after a host
  /// restart.
  static final GolubInstanceManager instance = _initInstance();

  // Expando is used because it doesn't prevent its keys from becoming
  // inaccessible. This allows the manager to efficiently retrieve an identifier
  // of an instance without holding a strong reference to that instance.
  //
  // It also doesn't use `==` to search for identifiers, which would lead to an
  // infinite loop when comparing an object to its copy. (i.e. which was caused
  // by calling instanceManager.getIdentifier() inside of `==` while this was a
  // HashMap).
  final Expando<int> _identifiers = Expando<int>();
  final Map<int, WeakReference<GolubInternalProxyApiBaseClass>> _weakInstances =
      <int, WeakReference<GolubInternalProxyApiBaseClass>>{};
  final Map<int, GolubInternalProxyApiBaseClass> _strongInstances =
      <int, GolubInternalProxyApiBaseClass>{};
  late final Finalizer<int> _finalizer;
  int _nextIdentifier = 0;

  /// Called when a weak referenced instance is removed by [removeWeakReference]
  /// or becomes inaccessible.
  late final void Function(int) onWeakReferenceRemoved;

  static GolubInstanceManager _initInstance() {
    if (Platform.environment['FLUTTER_TEST'] == 'true') {
      return GolubInstanceManager(onWeakReferenceRemoved: (_) {});
    }
    WidgetsFlutterBinding.ensureInitialized();
    final _GolubInternalInstanceManagerApi api =
        _GolubInternalInstanceManagerApi();
    // Clears the native `GolubInstanceManager` on the initial use of the Dart one.
    api.clear();
    final GolubInstanceManager instanceManager = GolubInstanceManager(
      onWeakReferenceRemoved: (int identifier) {
        api.removeStrongReference(identifier);
      },
    );
    _GolubInternalInstanceManagerApi.setUpMessageHandlers(
      instanceManager: instanceManager,
    );
    ProxyApiTestClass.golub_setUpMessageHandlers(
      golub_instanceManager: instanceManager,
    );
    ProxyApiSuperClass.golub_setUpMessageHandlers(
      golub_instanceManager: instanceManager,
    );
    ProxyApiInterface.golub_setUpMessageHandlers(
      golub_instanceManager: instanceManager,
    );
    ClassWithApiRequirement.golub_setUpMessageHandlers(
      golub_instanceManager: instanceManager,
    );
    return instanceManager;
  }

  /// Adds a new instance that was instantiated by Dart.
  ///
  /// In other words, Dart wants to add a new instance that will represent
  /// an object that will be instantiated on the host platform.
  ///
  /// Throws assertion error if the instance has already been added.
  ///
  /// Returns the randomly generated id of the [instance] added.
  int addDartCreatedInstance(GolubInternalProxyApiBaseClass instance) {
    assert(getIdentifier(instance) == null);

    final int identifier = _nextUniqueIdentifier();
    _identifiers[instance] = identifier;
    _weakInstances[identifier] = WeakReference<GolubInternalProxyApiBaseClass>(
      instance,
    );
    _finalizer.attach(instance, identifier, detach: instance);

    final GolubInternalProxyApiBaseClass copy = instance.golub_copy();
    _identifiers[copy] = identifier;
    _strongInstances[identifier] = copy;
    return identifier;
  }

  /// Removes the instance, if present, and call [onWeakReferenceRemoved] with
  /// its identifier.
  ///
  /// Returns the identifier associated with the removed instance. Otherwise,
  /// `null` if the instance was not found in this manager.
  ///
  /// This does not remove the strong referenced instance associated with
  /// [instance]. This can be done with [remove].
  int? removeWeakReference(GolubInternalProxyApiBaseClass instance) {
    final int? identifier = getIdentifier(instance);
    if (identifier == null) {
      return null;
    }

    _identifiers[instance] = null;
    _finalizer.detach(instance);
    onWeakReferenceRemoved(identifier);

    return identifier;
  }

  /// Removes [identifier] and its associated strongly referenced instance, if
  /// present, from the manager.
  ///
  /// Returns the strong referenced instance associated with [identifier] before
  /// it was removed. Returns `null` if [identifier] was not associated with
  /// any strong reference.
  ///
  /// Throws an `AssertionError` if the weak referenced instance associated with
  /// [identifier] is not removed first. This can be done with
  /// [removeWeakReference].
  T? remove<T extends GolubInternalProxyApiBaseClass>(int identifier) {
    final T? instance = _weakInstances[identifier]?.target as T?;
    assert(
      instance == null,
      'A strong instance with identifier $identifier is being removed despite the weak reference still existing: $instance',
    );
    return _strongInstances.remove(identifier) as T?;
  }

  /// Retrieves the instance associated with identifier.
  ///
  /// The value returned is chosen from the following order:
  ///
  /// 1. A weakly referenced instance associated with identifier.
  /// 2. If the only instance associated with identifier is a strongly
  /// referenced instance, a copy of the instance is added as a weak reference
  /// with the same identifier. Returning the newly created copy.
  /// 3. If no instance is associated with identifier, returns null.
  ///
  /// This method also expects the host `InstanceManager` to have a strong
  /// reference to the instance the identifier is associated with.
  T? getInstanceWithWeakReference<T extends GolubInternalProxyApiBaseClass>(
    int identifier,
  ) {
    final GolubInternalProxyApiBaseClass? weakInstance =
        _weakInstances[identifier]?.target;

    if (weakInstance == null) {
      final GolubInternalProxyApiBaseClass? strongInstance =
          _strongInstances[identifier];
      if (strongInstance != null) {
        final GolubInternalProxyApiBaseClass copy = strongInstance.golub_copy();
        _identifiers[copy] = identifier;
        _weakInstances[identifier] =
            WeakReference<GolubInternalProxyApiBaseClass>(copy);
        _finalizer.attach(copy, identifier, detach: copy);
        return copy as T;
      }
      return strongInstance as T?;
    }

    return weakInstance as T;
  }

  /// Retrieves the identifier associated with instance.
  int? getIdentifier(GolubInternalProxyApiBaseClass instance) {
    return _identifiers[instance];
  }

  /// Adds a new instance that was instantiated by the host platform.
  ///
  /// In other words, the host platform wants to add a new instance that
  /// represents an object on the host platform. Stored with [identifier].
  ///
  /// Throws assertion error if the instance or its identifier has already been
  /// added.
  void addHostCreatedInstance(
    GolubInternalProxyApiBaseClass instance,
    int identifier,
  ) {
    assert(!containsIdentifier(identifier));
    assert(getIdentifier(instance) == null);
    assert(identifier >= 0);

    _identifiers[instance] = identifier;
    _strongInstances[identifier] = instance;
  }

  /// Whether this manager contains the given [identifier].
  bool containsIdentifier(int identifier) {
    return _weakInstances.containsKey(identifier) ||
        _strongInstances.containsKey(identifier);
  }

  int _nextUniqueIdentifier() {
    late int identifier;
    do {
      identifier = _nextIdentifier;
      _nextIdentifier = (_nextIdentifier + 1) % _maxDartCreatedIdentifier;
    } while (containsIdentifier(identifier));
    return identifier;
  }
}

/// Generated API for managing the Dart and native `GolubInstanceManager`s.
class _GolubInternalInstanceManagerApi {
  /// Constructor for [_GolubInternalInstanceManagerApi].
  _GolubInternalInstanceManagerApi({BinaryMessenger? binaryMessenger})
    : golubVar_binaryMessenger = binaryMessenger;

  final BinaryMessenger? golubVar_binaryMessenger;

  static const MessageCodec<Object?> golubChannelCodec = _GolubCodec();

  static void setUpMessageHandlers({
    bool golub_clearHandlers = false,
    BinaryMessenger? binaryMessenger,
    GolubInstanceManager? instanceManager,
  }) {
    {
      final BasicMessageChannel<Object?>
      golubVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golub.golub_integration_tests.GolubInternalInstanceManager.removeStrongReference',
        golubChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (golub_clearHandlers) {
        golubVar_channel.setMessageHandler(null);
      } else {
        golubVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golub.golub_integration_tests.GolubInternalInstanceManager.removeStrongReference was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final int? arg_identifier = (args[0] as int?);
          assert(
            arg_identifier != null,
            'Argument for dev.bayori.golub.golub_integration_tests.GolubInternalInstanceManager.removeStrongReference was null, expected non-null int.',
          );
          try {
            (instanceManager ?? GolubInstanceManager.instance).remove(
              arg_identifier!,
            );
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
  }

  Future<void> removeStrongReference(int identifier) async {
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.GolubInternalInstanceManager.removeStrongReference';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      identifier,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Clear the native `GolubInstanceManager`.
  ///
  /// This is typically called after a hot restart.
  Future<void> clear() async {
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.GolubInternalInstanceManager.clear';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(null);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return;
    }
  }
}

class _GolubInternalProxyApiBaseCodec extends _GolubCodec {
  const _GolubInternalProxyApiBaseCodec(this.instanceManager);
  final GolubInstanceManager instanceManager;
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is GolubInternalProxyApiBaseClass) {
      buffer.putUint8(128);
      writeValue(buffer, instanceManager.getIdentifier(value));
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:
        return instanceManager.getInstanceWithWeakReference(
          readValue(buffer)! as int,
        );
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

enum ProxyApiTestEnum {
  one,
  two,
  three,
}

class _GolubCodec extends StandardMessageCodec {
  const _GolubCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is int) {
      buffer.putUint8(4);
      buffer.putInt64(value);
    } else if (value is ProxyApiTestEnum) {
      buffer.putUint8(129);
      writeValue(buffer, value.index);
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 129:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : ProxyApiTestEnum.values[value];
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

/// The core ProxyApi test class that each supported host language must
/// implement in platform_tests integration tests.
class ProxyApiTestClass extends ProxyApiSuperClass
    implements ProxyApiInterface {
  factory ProxyApiTestClass({
    BinaryMessenger? golub_binaryMessenger,
    GolubInstanceManager? golub_instanceManager,
    required bool aBool,
    required int anInt,
    required double aDouble,
    required String aString,
    required Uint8List aUint8List,
    required List<Object?> aList,
    required Map<String?, Object?> aMap,
    required ProxyApiTestEnum anEnum,
    required ProxyApiSuperClass aProxyApi,
    bool? aNullableBool,
    int? aNullableInt,
    double? aNullableDouble,
    String? aNullableString,
    Uint8List? aNullableUint8List,
    List<Object?>? aNullableList,
    Map<String?, Object?>? aNullableMap,
    ProxyApiTestEnum? aNullableEnum,
    ProxyApiSuperClass? aNullableProxyApi,
    void Function(ProxyApiInterface golub_instance)? anInterfaceMethod,
    void Function(ProxyApiTestClass golub_instance)? flutterNoop,
    Object? Function(ProxyApiTestClass golub_instance)? flutterThrowError,
    void Function(ProxyApiTestClass golub_instance)? flutterThrowErrorFromVoid,
    required bool Function(
      ProxyApiTestClass golub_instance,
      bool aBool,
    )
    flutterEchoBool,
    required int Function(
      ProxyApiTestClass golub_instance,
      int anInt,
    )
    flutterEchoInt,
    required double Function(
      ProxyApiTestClass golub_instance,
      double aDouble,
    )
    flutterEchoDouble,
    required String Function(
      ProxyApiTestClass golub_instance,
      String aString,
    )
    flutterEchoString,
    required Uint8List Function(
      ProxyApiTestClass golub_instance,
      Uint8List aList,
    )
    flutterEchoUint8List,
    required List<Object?> Function(
      ProxyApiTestClass golub_instance,
      List<Object?> aList,
    )
    flutterEchoList,
    required List<ProxyApiTestClass?> Function(
      ProxyApiTestClass golub_instance,
      List<ProxyApiTestClass?> aList,
    )
    flutterEchoProxyApiList,
    required Map<String?, Object?> Function(
      ProxyApiTestClass golub_instance,
      Map<String?, Object?> aMap,
    )
    flutterEchoMap,
    required Map<String?, ProxyApiTestClass?> Function(
      ProxyApiTestClass golub_instance,
      Map<String?, ProxyApiTestClass?> aMap,
    )
    flutterEchoProxyApiMap,
    required ProxyApiTestEnum Function(
      ProxyApiTestClass golub_instance,
      ProxyApiTestEnum anEnum,
    )
    flutterEchoEnum,
    required ProxyApiSuperClass Function(
      ProxyApiTestClass golub_instance,
      ProxyApiSuperClass aProxyApi,
    )
    flutterEchoProxyApi,
    bool? Function(
      ProxyApiTestClass golub_instance,
      bool? aBool,
    )?
    flutterEchoNullableBool,
    int? Function(
      ProxyApiTestClass golub_instance,
      int? anInt,
    )?
    flutterEchoNullableInt,
    double? Function(
      ProxyApiTestClass golub_instance,
      double? aDouble,
    )?
    flutterEchoNullableDouble,
    String? Function(
      ProxyApiTestClass golub_instance,
      String? aString,
    )?
    flutterEchoNullableString,
    Uint8List? Function(
      ProxyApiTestClass golub_instance,
      Uint8List? aList,
    )?
    flutterEchoNullableUint8List,
    List<Object?>? Function(
      ProxyApiTestClass golub_instance,
      List<Object?>? aList,
    )?
    flutterEchoNullableList,
    Map<String?, Object?>? Function(
      ProxyApiTestClass golub_instance,
      Map<String?, Object?>? aMap,
    )?
    flutterEchoNullableMap,
    ProxyApiTestEnum? Function(
      ProxyApiTestClass golub_instance,
      ProxyApiTestEnum? anEnum,
    )?
    flutterEchoNullableEnum,
    ProxyApiSuperClass? Function(
      ProxyApiTestClass golub_instance,
      ProxyApiSuperClass? aProxyApi,
    )?
    flutterEchoNullableProxyApi,
    Future<void> Function(ProxyApiTestClass golub_instance)? flutterNoopAsync,
    required Future<String> Function(
      ProxyApiTestClass golub_instance,
      String aString,
    )
    flutterEchoAsyncString,
    required bool boolParam,
    required int intParam,
    required double doubleParam,
    required String stringParam,
    required Uint8List aUint8ListParam,
    required List<Object?> listParam,
    required Map<String?, Object?> mapParam,
    required ProxyApiTestEnum enumParam,
    required ProxyApiSuperClass proxyApiParam,
    bool? nullableBoolParam,
    int? nullableIntParam,
    double? nullableDoubleParam,
    String? nullableStringParam,
    Uint8List? nullableUint8ListParam,
    List<Object?>? nullableListParam,
    Map<String?, Object?>? nullableMapParam,
    ProxyApiTestEnum? nullableEnumParam,
    ProxyApiSuperClass? nullableProxyApiParam,
  }) {
    if (GolubOverrides.proxyApiTestClass_new != null) {
      return GolubOverrides.proxyApiTestClass_new!(
        aBool: aBool,
        anInt: anInt,
        aDouble: aDouble,
        aString: aString,
        aUint8List: aUint8List,
        aList: aList,
        aMap: aMap,
        anEnum: anEnum,
        aProxyApi: aProxyApi,
        aNullableBool: aNullableBool,
        aNullableInt: aNullableInt,
        aNullableDouble: aNullableDouble,
        aNullableString: aNullableString,
        aNullableUint8List: aNullableUint8List,
        aNullableList: aNullableList,
        aNullableMap: aNullableMap,
        aNullableEnum: aNullableEnum,
        aNullableProxyApi: aNullableProxyApi,
        anInterfaceMethod: anInterfaceMethod,
        flutterNoop: flutterNoop,
        flutterThrowError: flutterThrowError,
        flutterThrowErrorFromVoid: flutterThrowErrorFromVoid,
        flutterEchoBool: flutterEchoBool,
        flutterEchoInt: flutterEchoInt,
        flutterEchoDouble: flutterEchoDouble,
        flutterEchoString: flutterEchoString,
        flutterEchoUint8List: flutterEchoUint8List,
        flutterEchoList: flutterEchoList,
        flutterEchoProxyApiList: flutterEchoProxyApiList,
        flutterEchoMap: flutterEchoMap,
        flutterEchoProxyApiMap: flutterEchoProxyApiMap,
        flutterEchoEnum: flutterEchoEnum,
        flutterEchoProxyApi: flutterEchoProxyApi,
        flutterEchoNullableBool: flutterEchoNullableBool,
        flutterEchoNullableInt: flutterEchoNullableInt,
        flutterEchoNullableDouble: flutterEchoNullableDouble,
        flutterEchoNullableString: flutterEchoNullableString,
        flutterEchoNullableUint8List: flutterEchoNullableUint8List,
        flutterEchoNullableList: flutterEchoNullableList,
        flutterEchoNullableMap: flutterEchoNullableMap,
        flutterEchoNullableEnum: flutterEchoNullableEnum,
        flutterEchoNullableProxyApi: flutterEchoNullableProxyApi,
        flutterNoopAsync: flutterNoopAsync,
        flutterEchoAsyncString: flutterEchoAsyncString,
        boolParam: boolParam,
        intParam: intParam,
        doubleParam: doubleParam,
        stringParam: stringParam,
        aUint8ListParam: aUint8ListParam,
        listParam: listParam,
        mapParam: mapParam,
        enumParam: enumParam,
        proxyApiParam: proxyApiParam,
        nullableBoolParam: nullableBoolParam,
        nullableIntParam: nullableIntParam,
        nullableDoubleParam: nullableDoubleParam,
        nullableStringParam: nullableStringParam,
        nullableUint8ListParam: nullableUint8ListParam,
        nullableListParam: nullableListParam,
        nullableMapParam: nullableMapParam,
        nullableEnumParam: nullableEnumParam,
        nullableProxyApiParam: nullableProxyApiParam,
      );
    }
    return ProxyApiTestClass.golub_new(
      golub_binaryMessenger: golub_binaryMessenger,
      golub_instanceManager: golub_instanceManager,
      aBool: aBool,
      anInt: anInt,
      aDouble: aDouble,
      aString: aString,
      aUint8List: aUint8List,
      aList: aList,
      aMap: aMap,
      anEnum: anEnum,
      aProxyApi: aProxyApi,
      aNullableBool: aNullableBool,
      aNullableInt: aNullableInt,
      aNullableDouble: aNullableDouble,
      aNullableString: aNullableString,
      aNullableUint8List: aNullableUint8List,
      aNullableList: aNullableList,
      aNullableMap: aNullableMap,
      aNullableEnum: aNullableEnum,
      aNullableProxyApi: aNullableProxyApi,
      anInterfaceMethod: anInterfaceMethod,
      flutterNoop: flutterNoop,
      flutterThrowError: flutterThrowError,
      flutterThrowErrorFromVoid: flutterThrowErrorFromVoid,
      flutterEchoBool: flutterEchoBool,
      flutterEchoInt: flutterEchoInt,
      flutterEchoDouble: flutterEchoDouble,
      flutterEchoString: flutterEchoString,
      flutterEchoUint8List: flutterEchoUint8List,
      flutterEchoList: flutterEchoList,
      flutterEchoProxyApiList: flutterEchoProxyApiList,
      flutterEchoMap: flutterEchoMap,
      flutterEchoProxyApiMap: flutterEchoProxyApiMap,
      flutterEchoEnum: flutterEchoEnum,
      flutterEchoProxyApi: flutterEchoProxyApi,
      flutterEchoNullableBool: flutterEchoNullableBool,
      flutterEchoNullableInt: flutterEchoNullableInt,
      flutterEchoNullableDouble: flutterEchoNullableDouble,
      flutterEchoNullableString: flutterEchoNullableString,
      flutterEchoNullableUint8List: flutterEchoNullableUint8List,
      flutterEchoNullableList: flutterEchoNullableList,
      flutterEchoNullableMap: flutterEchoNullableMap,
      flutterEchoNullableEnum: flutterEchoNullableEnum,
      flutterEchoNullableProxyApi: flutterEchoNullableProxyApi,
      flutterNoopAsync: flutterNoopAsync,
      flutterEchoAsyncString: flutterEchoAsyncString,
      boolParam: boolParam,
      intParam: intParam,
      doubleParam: doubleParam,
      stringParam: stringParam,
      aUint8ListParam: aUint8ListParam,
      listParam: listParam,
      mapParam: mapParam,
      enumParam: enumParam,
      proxyApiParam: proxyApiParam,
      nullableBoolParam: nullableBoolParam,
      nullableIntParam: nullableIntParam,
      nullableDoubleParam: nullableDoubleParam,
      nullableStringParam: nullableStringParam,
      nullableUint8ListParam: nullableUint8ListParam,
      nullableListParam: nullableListParam,
      nullableMapParam: nullableMapParam,
      nullableEnumParam: nullableEnumParam,
      nullableProxyApiParam: nullableProxyApiParam,
    );
  }

  @protected
  ProxyApiTestClass.golub_new({
    super.golub_binaryMessenger,
    super.golub_instanceManager,
    required this.aBool,
    required this.anInt,
    required this.aDouble,
    required this.aString,
    required this.aUint8List,
    required this.aList,
    required this.aMap,
    required this.anEnum,
    required this.aProxyApi,
    this.aNullableBool,
    this.aNullableInt,
    this.aNullableDouble,
    this.aNullableString,
    this.aNullableUint8List,
    this.aNullableList,
    this.aNullableMap,
    this.aNullableEnum,
    this.aNullableProxyApi,
    this.anInterfaceMethod,
    this.flutterNoop,
    this.flutterThrowError,
    this.flutterThrowErrorFromVoid,
    required this.flutterEchoBool,
    required this.flutterEchoInt,
    required this.flutterEchoDouble,
    required this.flutterEchoString,
    required this.flutterEchoUint8List,
    required this.flutterEchoList,
    required this.flutterEchoProxyApiList,
    required this.flutterEchoMap,
    required this.flutterEchoProxyApiMap,
    required this.flutterEchoEnum,
    required this.flutterEchoProxyApi,
    this.flutterEchoNullableBool,
    this.flutterEchoNullableInt,
    this.flutterEchoNullableDouble,
    this.flutterEchoNullableString,
    this.flutterEchoNullableUint8List,
    this.flutterEchoNullableList,
    this.flutterEchoNullableMap,
    this.flutterEchoNullableEnum,
    this.flutterEchoNullableProxyApi,
    this.flutterNoopAsync,
    required this.flutterEchoAsyncString,
    required bool boolParam,
    required int intParam,
    required double doubleParam,
    required String stringParam,
    required Uint8List aUint8ListParam,
    required List<Object?> listParam,
    required Map<String?, Object?> mapParam,
    required ProxyApiTestEnum enumParam,
    required ProxyApiSuperClass proxyApiParam,
    bool? nullableBoolParam,
    int? nullableIntParam,
    double? nullableDoubleParam,
    String? nullableStringParam,
    Uint8List? nullableUint8ListParam,
    List<Object?>? nullableListParam,
    Map<String?, Object?>? nullableMapParam,
    ProxyApiTestEnum? nullableEnumParam,
    ProxyApiSuperClass? nullableProxyApiParam,
  }) : super.golub_detached() {
    final int golubVar_instanceIdentifier = golub_instanceManager
        .addDartCreatedInstance(this);
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.golub_defaultConstructor';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      golubVar_instanceIdentifier,
      aBool,
      anInt,
      aDouble,
      aString,
      aUint8List,
      aList,
      aMap,
      anEnum,
      aProxyApi,
      aNullableBool,
      aNullableInt,
      aNullableDouble,
      aNullableString,
      aNullableUint8List,
      aNullableList,
      aNullableMap,
      aNullableEnum,
      aNullableProxyApi,
      boolParam,
      intParam,
      doubleParam,
      stringParam,
      aUint8ListParam,
      listParam,
      mapParam,
      enumParam,
      proxyApiParam,
      nullableBoolParam,
      nullableIntParam,
      nullableDoubleParam,
      nullableStringParam,
      nullableUint8ListParam,
      nullableListParam,
      nullableMapParam,
      nullableEnumParam,
      nullableProxyApiParam,
    ]);
    () async {
      final List<Object?>? golubVar_replyList =
          await golubVar_sendFuture as List<Object?>?;
      if (golubVar_replyList == null) {
        throw _createConnectionError(golubVar_channelName);
      } else if (golubVar_replyList.length > 1) {
        throw PlatformException(
          code: golubVar_replyList[0]! as String,
          message: golubVar_replyList[1] as String?,
          details: golubVar_replyList[2],
        );
      } else {
        return;
      }
    }();
  }

  factory ProxyApiTestClass.namedConstructor({
    BinaryMessenger? golub_binaryMessenger,
    GolubInstanceManager? golub_instanceManager,
    required bool aBool,
    required int anInt,
    required double aDouble,
    required String aString,
    required Uint8List aUint8List,
    required List<Object?> aList,
    required Map<String?, Object?> aMap,
    required ProxyApiTestEnum anEnum,
    required ProxyApiSuperClass aProxyApi,
    bool? aNullableBool,
    int? aNullableInt,
    double? aNullableDouble,
    String? aNullableString,
    Uint8List? aNullableUint8List,
    List<Object?>? aNullableList,
    Map<String?, Object?>? aNullableMap,
    ProxyApiTestEnum? aNullableEnum,
    ProxyApiSuperClass? aNullableProxyApi,
    void Function(ProxyApiInterface golub_instance)? anInterfaceMethod,
    void Function(ProxyApiTestClass golub_instance)? flutterNoop,
    Object? Function(ProxyApiTestClass golub_instance)? flutterThrowError,
    void Function(ProxyApiTestClass golub_instance)? flutterThrowErrorFromVoid,
    required bool Function(
      ProxyApiTestClass golub_instance,
      bool aBool,
    )
    flutterEchoBool,
    required int Function(
      ProxyApiTestClass golub_instance,
      int anInt,
    )
    flutterEchoInt,
    required double Function(
      ProxyApiTestClass golub_instance,
      double aDouble,
    )
    flutterEchoDouble,
    required String Function(
      ProxyApiTestClass golub_instance,
      String aString,
    )
    flutterEchoString,
    required Uint8List Function(
      ProxyApiTestClass golub_instance,
      Uint8List aList,
    )
    flutterEchoUint8List,
    required List<Object?> Function(
      ProxyApiTestClass golub_instance,
      List<Object?> aList,
    )
    flutterEchoList,
    required List<ProxyApiTestClass?> Function(
      ProxyApiTestClass golub_instance,
      List<ProxyApiTestClass?> aList,
    )
    flutterEchoProxyApiList,
    required Map<String?, Object?> Function(
      ProxyApiTestClass golub_instance,
      Map<String?, Object?> aMap,
    )
    flutterEchoMap,
    required Map<String?, ProxyApiTestClass?> Function(
      ProxyApiTestClass golub_instance,
      Map<String?, ProxyApiTestClass?> aMap,
    )
    flutterEchoProxyApiMap,
    required ProxyApiTestEnum Function(
      ProxyApiTestClass golub_instance,
      ProxyApiTestEnum anEnum,
    )
    flutterEchoEnum,
    required ProxyApiSuperClass Function(
      ProxyApiTestClass golub_instance,
      ProxyApiSuperClass aProxyApi,
    )
    flutterEchoProxyApi,
    bool? Function(
      ProxyApiTestClass golub_instance,
      bool? aBool,
    )?
    flutterEchoNullableBool,
    int? Function(
      ProxyApiTestClass golub_instance,
      int? anInt,
    )?
    flutterEchoNullableInt,
    double? Function(
      ProxyApiTestClass golub_instance,
      double? aDouble,
    )?
    flutterEchoNullableDouble,
    String? Function(
      ProxyApiTestClass golub_instance,
      String? aString,
    )?
    flutterEchoNullableString,
    Uint8List? Function(
      ProxyApiTestClass golub_instance,
      Uint8List? aList,
    )?
    flutterEchoNullableUint8List,
    List<Object?>? Function(
      ProxyApiTestClass golub_instance,
      List<Object?>? aList,
    )?
    flutterEchoNullableList,
    Map<String?, Object?>? Function(
      ProxyApiTestClass golub_instance,
      Map<String?, Object?>? aMap,
    )?
    flutterEchoNullableMap,
    ProxyApiTestEnum? Function(
      ProxyApiTestClass golub_instance,
      ProxyApiTestEnum? anEnum,
    )?
    flutterEchoNullableEnum,
    ProxyApiSuperClass? Function(
      ProxyApiTestClass golub_instance,
      ProxyApiSuperClass? aProxyApi,
    )?
    flutterEchoNullableProxyApi,
    Future<void> Function(ProxyApiTestClass golub_instance)? flutterNoopAsync,
    required Future<String> Function(
      ProxyApiTestClass golub_instance,
      String aString,
    )
    flutterEchoAsyncString,
  }) {
    if (GolubOverrides.proxyApiTestClass_namedConstructor != null) {
      return GolubOverrides.proxyApiTestClass_namedConstructor!(
        aBool: aBool,
        anInt: anInt,
        aDouble: aDouble,
        aString: aString,
        aUint8List: aUint8List,
        aList: aList,
        aMap: aMap,
        anEnum: anEnum,
        aProxyApi: aProxyApi,
        aNullableBool: aNullableBool,
        aNullableInt: aNullableInt,
        aNullableDouble: aNullableDouble,
        aNullableString: aNullableString,
        aNullableUint8List: aNullableUint8List,
        aNullableList: aNullableList,
        aNullableMap: aNullableMap,
        aNullableEnum: aNullableEnum,
        aNullableProxyApi: aNullableProxyApi,
        anInterfaceMethod: anInterfaceMethod,
        flutterNoop: flutterNoop,
        flutterThrowError: flutterThrowError,
        flutterThrowErrorFromVoid: flutterThrowErrorFromVoid,
        flutterEchoBool: flutterEchoBool,
        flutterEchoInt: flutterEchoInt,
        flutterEchoDouble: flutterEchoDouble,
        flutterEchoString: flutterEchoString,
        flutterEchoUint8List: flutterEchoUint8List,
        flutterEchoList: flutterEchoList,
        flutterEchoProxyApiList: flutterEchoProxyApiList,
        flutterEchoMap: flutterEchoMap,
        flutterEchoProxyApiMap: flutterEchoProxyApiMap,
        flutterEchoEnum: flutterEchoEnum,
        flutterEchoProxyApi: flutterEchoProxyApi,
        flutterEchoNullableBool: flutterEchoNullableBool,
        flutterEchoNullableInt: flutterEchoNullableInt,
        flutterEchoNullableDouble: flutterEchoNullableDouble,
        flutterEchoNullableString: flutterEchoNullableString,
        flutterEchoNullableUint8List: flutterEchoNullableUint8List,
        flutterEchoNullableList: flutterEchoNullableList,
        flutterEchoNullableMap: flutterEchoNullableMap,
        flutterEchoNullableEnum: flutterEchoNullableEnum,
        flutterEchoNullableProxyApi: flutterEchoNullableProxyApi,
        flutterNoopAsync: flutterNoopAsync,
        flutterEchoAsyncString: flutterEchoAsyncString,
      );
    }
    return ProxyApiTestClass.golub_namedConstructor(
      golub_binaryMessenger: golub_binaryMessenger,
      golub_instanceManager: golub_instanceManager,
      aBool: aBool,
      anInt: anInt,
      aDouble: aDouble,
      aString: aString,
      aUint8List: aUint8List,
      aList: aList,
      aMap: aMap,
      anEnum: anEnum,
      aProxyApi: aProxyApi,
      aNullableBool: aNullableBool,
      aNullableInt: aNullableInt,
      aNullableDouble: aNullableDouble,
      aNullableString: aNullableString,
      aNullableUint8List: aNullableUint8List,
      aNullableList: aNullableList,
      aNullableMap: aNullableMap,
      aNullableEnum: aNullableEnum,
      aNullableProxyApi: aNullableProxyApi,
      anInterfaceMethod: anInterfaceMethod,
      flutterNoop: flutterNoop,
      flutterThrowError: flutterThrowError,
      flutterThrowErrorFromVoid: flutterThrowErrorFromVoid,
      flutterEchoBool: flutterEchoBool,
      flutterEchoInt: flutterEchoInt,
      flutterEchoDouble: flutterEchoDouble,
      flutterEchoString: flutterEchoString,
      flutterEchoUint8List: flutterEchoUint8List,
      flutterEchoList: flutterEchoList,
      flutterEchoProxyApiList: flutterEchoProxyApiList,
      flutterEchoMap: flutterEchoMap,
      flutterEchoProxyApiMap: flutterEchoProxyApiMap,
      flutterEchoEnum: flutterEchoEnum,
      flutterEchoProxyApi: flutterEchoProxyApi,
      flutterEchoNullableBool: flutterEchoNullableBool,
      flutterEchoNullableInt: flutterEchoNullableInt,
      flutterEchoNullableDouble: flutterEchoNullableDouble,
      flutterEchoNullableString: flutterEchoNullableString,
      flutterEchoNullableUint8List: flutterEchoNullableUint8List,
      flutterEchoNullableList: flutterEchoNullableList,
      flutterEchoNullableMap: flutterEchoNullableMap,
      flutterEchoNullableEnum: flutterEchoNullableEnum,
      flutterEchoNullableProxyApi: flutterEchoNullableProxyApi,
      flutterNoopAsync: flutterNoopAsync,
      flutterEchoAsyncString: flutterEchoAsyncString,
    );
  }

  @protected
  ProxyApiTestClass.golub_namedConstructor({
    super.golub_binaryMessenger,
    super.golub_instanceManager,
    required this.aBool,
    required this.anInt,
    required this.aDouble,
    required this.aString,
    required this.aUint8List,
    required this.aList,
    required this.aMap,
    required this.anEnum,
    required this.aProxyApi,
    this.aNullableBool,
    this.aNullableInt,
    this.aNullableDouble,
    this.aNullableString,
    this.aNullableUint8List,
    this.aNullableList,
    this.aNullableMap,
    this.aNullableEnum,
    this.aNullableProxyApi,
    this.anInterfaceMethod,
    this.flutterNoop,
    this.flutterThrowError,
    this.flutterThrowErrorFromVoid,
    required this.flutterEchoBool,
    required this.flutterEchoInt,
    required this.flutterEchoDouble,
    required this.flutterEchoString,
    required this.flutterEchoUint8List,
    required this.flutterEchoList,
    required this.flutterEchoProxyApiList,
    required this.flutterEchoMap,
    required this.flutterEchoProxyApiMap,
    required this.flutterEchoEnum,
    required this.flutterEchoProxyApi,
    this.flutterEchoNullableBool,
    this.flutterEchoNullableInt,
    this.flutterEchoNullableDouble,
    this.flutterEchoNullableString,
    this.flutterEchoNullableUint8List,
    this.flutterEchoNullableList,
    this.flutterEchoNullableMap,
    this.flutterEchoNullableEnum,
    this.flutterEchoNullableProxyApi,
    this.flutterNoopAsync,
    required this.flutterEchoAsyncString,
  }) : super.golub_detached() {
    final int golubVar_instanceIdentifier = golub_instanceManager
        .addDartCreatedInstance(this);
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.namedConstructor';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      golubVar_instanceIdentifier,
      aBool,
      anInt,
      aDouble,
      aString,
      aUint8List,
      aList,
      aMap,
      anEnum,
      aProxyApi,
      aNullableBool,
      aNullableInt,
      aNullableDouble,
      aNullableString,
      aNullableUint8List,
      aNullableList,
      aNullableMap,
      aNullableEnum,
      aNullableProxyApi,
    ]);
    () async {
      final List<Object?>? golubVar_replyList =
          await golubVar_sendFuture as List<Object?>?;
      if (golubVar_replyList == null) {
        throw _createConnectionError(golubVar_channelName);
      } else if (golubVar_replyList.length > 1) {
        throw PlatformException(
          code: golubVar_replyList[0]! as String,
          message: golubVar_replyList[1] as String?,
          details: golubVar_replyList[2],
        );
      } else {
        return;
      }
    }();
  }

  /// Constructs [ProxyApiTestClass] without creating the associated native object.
  ///
  /// This should only be used by subclasses created by this library or to
  /// create copies for an [GolubInstanceManager].
  @protected
  ProxyApiTestClass.golub_detached({
    super.golub_binaryMessenger,
    super.golub_instanceManager,
    required this.aBool,
    required this.anInt,
    required this.aDouble,
    required this.aString,
    required this.aUint8List,
    required this.aList,
    required this.aMap,
    required this.anEnum,
    required this.aProxyApi,
    this.aNullableBool,
    this.aNullableInt,
    this.aNullableDouble,
    this.aNullableString,
    this.aNullableUint8List,
    this.aNullableList,
    this.aNullableMap,
    this.aNullableEnum,
    this.aNullableProxyApi,
    this.anInterfaceMethod,
    this.flutterNoop,
    this.flutterThrowError,
    this.flutterThrowErrorFromVoid,
    required this.flutterEchoBool,
    required this.flutterEchoInt,
    required this.flutterEchoDouble,
    required this.flutterEchoString,
    required this.flutterEchoUint8List,
    required this.flutterEchoList,
    required this.flutterEchoProxyApiList,
    required this.flutterEchoMap,
    required this.flutterEchoProxyApiMap,
    required this.flutterEchoEnum,
    required this.flutterEchoProxyApi,
    this.flutterEchoNullableBool,
    this.flutterEchoNullableInt,
    this.flutterEchoNullableDouble,
    this.flutterEchoNullableString,
    this.flutterEchoNullableUint8List,
    this.flutterEchoNullableList,
    this.flutterEchoNullableMap,
    this.flutterEchoNullableEnum,
    this.flutterEchoNullableProxyApi,
    this.flutterNoopAsync,
    required this.flutterEchoAsyncString,
  }) : super.golub_detached();

  late final _GolubInternalProxyApiBaseCodec _golubVar_codecProxyApiTestClass =
      _GolubInternalProxyApiBaseCodec(golub_instanceManager);

  final bool aBool;

  final int anInt;

  final double aDouble;

  final String aString;

  final Uint8List aUint8List;

  final List<Object?> aList;

  final Map<String?, Object?> aMap;

  final ProxyApiTestEnum anEnum;

  final ProxyApiSuperClass aProxyApi;

  final bool? aNullableBool;

  final int? aNullableInt;

  final double? aNullableDouble;

  final String? aNullableString;

  final Uint8List? aNullableUint8List;

  final List<Object?>? aNullableList;

  final Map<String?, Object?>? aNullableMap;

  final ProxyApiTestEnum? aNullableEnum;

  final ProxyApiSuperClass? aNullableProxyApi;

  /// A no-op function taking no arguments and returning no value, to sanity
  /// test basic calling.
  ///
  /// For the associated Native object to be automatically garbage collected,
  /// it is required that the implementation of this `Function` doesn't have a
  /// strong reference to the encapsulating class instance. When this `Function`
  /// references a non-local variable, it is strongly recommended to access it
  /// with a `WeakReference`:
  ///
  /// ```dart
  /// final WeakReference weakMyVariable = WeakReference(myVariable);
  /// final ProxyApiTestClass instance = ProxyApiTestClass(
  ///  flutterNoop: (ProxyApiTestClass golub_instance, ...) {
  ///    print(weakMyVariable?.target);
  ///  },
  /// );
  /// ```
  ///
  /// Alternatively, [GolubInstanceManager.removeWeakReference] can be used to
  /// release the associated Native object manually.
  final void Function(ProxyApiTestClass golub_instance)? flutterNoop;

  /// Responds with an error from an async function returning a value.
  ///
  /// For the associated Native object to be automatically garbage collected,
  /// it is required that the implementation of this `Function` doesn't have a
  /// strong reference to the encapsulating class instance. When this `Function`
  /// references a non-local variable, it is strongly recommended to access it
  /// with a `WeakReference`:
  ///
  /// ```dart
  /// final WeakReference weakMyVariable = WeakReference(myVariable);
  /// final ProxyApiTestClass instance = ProxyApiTestClass(
  ///  flutterThrowError: (ProxyApiTestClass golub_instance, ...) {
  ///    print(weakMyVariable?.target);
  ///  },
  /// );
  /// ```
  ///
  /// Alternatively, [GolubInstanceManager.removeWeakReference] can be used to
  /// release the associated Native object manually.
  final Object? Function(ProxyApiTestClass golub_instance)? flutterThrowError;

  /// Responds with an error from an async void function.
  ///
  /// For the associated Native object to be automatically garbage collected,
  /// it is required that the implementation of this `Function` doesn't have a
  /// strong reference to the encapsulating class instance. When this `Function`
  /// references a non-local variable, it is strongly recommended to access it
  /// with a `WeakReference`:
  ///
  /// ```dart
  /// final WeakReference weakMyVariable = WeakReference(myVariable);
  /// final ProxyApiTestClass instance = ProxyApiTestClass(
  ///  flutterThrowErrorFromVoid: (ProxyApiTestClass golub_instance, ...) {
  ///    print(weakMyVariable?.target);
  ///  },
  /// );
  /// ```
  ///
  /// Alternatively, [GolubInstanceManager.removeWeakReference] can be used to
  /// release the associated Native object manually.
  final void Function(ProxyApiTestClass golub_instance)?
  flutterThrowErrorFromVoid;

  /// Returns the passed boolean, to test serialization and deserialization.
  ///
  /// For the associated Native object to be automatically garbage collected,
  /// it is required that the implementation of this `Function` doesn't have a
  /// strong reference to the encapsulating class instance. When this `Function`
  /// references a non-local variable, it is strongly recommended to access it
  /// with a `WeakReference`:
  ///
  /// ```dart
  /// final WeakReference weakMyVariable = WeakReference(myVariable);
  /// final ProxyApiTestClass instance = ProxyApiTestClass(
  ///  flutterEchoBool: (ProxyApiTestClass golub_instance, ...) {
  ///    print(weakMyVariable?.target);
  ///  },
  /// );
  /// ```
  ///
  /// Alternatively, [GolubInstanceManager.removeWeakReference] can be used to
  /// release the associated Native object manually.
  final bool Function(
    ProxyApiTestClass golub_instance,
    bool aBool,
  )
  flutterEchoBool;

  /// Returns the passed int, to test serialization and deserialization.
  ///
  /// For the associated Native object to be automatically garbage collected,
  /// it is required that the implementation of this `Function` doesn't have a
  /// strong reference to the encapsulating class instance. When this `Function`
  /// references a non-local variable, it is strongly recommended to access it
  /// with a `WeakReference`:
  ///
  /// ```dart
  /// final WeakReference weakMyVariable = WeakReference(myVariable);
  /// final ProxyApiTestClass instance = ProxyApiTestClass(
  ///  flutterEchoInt: (ProxyApiTestClass golub_instance, ...) {
  ///    print(weakMyVariable?.target);
  ///  },
  /// );
  /// ```
  ///
  /// Alternatively, [GolubInstanceManager.removeWeakReference] can be used to
  /// release the associated Native object manually.
  final int Function(
    ProxyApiTestClass golub_instance,
    int anInt,
  )
  flutterEchoInt;

  /// Returns the passed double, to test serialization and deserialization.
  ///
  /// For the associated Native object to be automatically garbage collected,
  /// it is required that the implementation of this `Function` doesn't have a
  /// strong reference to the encapsulating class instance. When this `Function`
  /// references a non-local variable, it is strongly recommended to access it
  /// with a `WeakReference`:
  ///
  /// ```dart
  /// final WeakReference weakMyVariable = WeakReference(myVariable);
  /// final ProxyApiTestClass instance = ProxyApiTestClass(
  ///  flutterEchoDouble: (ProxyApiTestClass golub_instance, ...) {
  ///    print(weakMyVariable?.target);
  ///  },
  /// );
  /// ```
  ///
  /// Alternatively, [GolubInstanceManager.removeWeakReference] can be used to
  /// release the associated Native object manually.
  final double Function(
    ProxyApiTestClass golub_instance,
    double aDouble,
  )
  flutterEchoDouble;

  /// Returns the passed string, to test serialization and deserialization.
  ///
  /// For the associated Native object to be automatically garbage collected,
  /// it is required that the implementation of this `Function` doesn't have a
  /// strong reference to the encapsulating class instance. When this `Function`
  /// references a non-local variable, it is strongly recommended to access it
  /// with a `WeakReference`:
  ///
  /// ```dart
  /// final WeakReference weakMyVariable = WeakReference(myVariable);
  /// final ProxyApiTestClass instance = ProxyApiTestClass(
  ///  flutterEchoString: (ProxyApiTestClass golub_instance, ...) {
  ///    print(weakMyVariable?.target);
  ///  },
  /// );
  /// ```
  ///
  /// Alternatively, [GolubInstanceManager.removeWeakReference] can be used to
  /// release the associated Native object manually.
  final String Function(
    ProxyApiTestClass golub_instance,
    String aString,
  )
  flutterEchoString;

  /// Returns the passed byte list, to test serialization and deserialization.
  ///
  /// For the associated Native object to be automatically garbage collected,
  /// it is required that the implementation of this `Function` doesn't have a
  /// strong reference to the encapsulating class instance. When this `Function`
  /// references a non-local variable, it is strongly recommended to access it
  /// with a `WeakReference`:
  ///
  /// ```dart
  /// final WeakReference weakMyVariable = WeakReference(myVariable);
  /// final ProxyApiTestClass instance = ProxyApiTestClass(
  ///  flutterEchoUint8List: (ProxyApiTestClass golub_instance, ...) {
  ///    print(weakMyVariable?.target);
  ///  },
  /// );
  /// ```
  ///
  /// Alternatively, [GolubInstanceManager.removeWeakReference] can be used to
  /// release the associated Native object manually.
  final Uint8List Function(
    ProxyApiTestClass golub_instance,
    Uint8List aList,
  )
  flutterEchoUint8List;

  /// Returns the passed list, to test serialization and deserialization.
  ///
  /// For the associated Native object to be automatically garbage collected,
  /// it is required that the implementation of this `Function` doesn't have a
  /// strong reference to the encapsulating class instance. When this `Function`
  /// references a non-local variable, it is strongly recommended to access it
  /// with a `WeakReference`:
  ///
  /// ```dart
  /// final WeakReference weakMyVariable = WeakReference(myVariable);
  /// final ProxyApiTestClass instance = ProxyApiTestClass(
  ///  flutterEchoList: (ProxyApiTestClass golub_instance, ...) {
  ///    print(weakMyVariable?.target);
  ///  },
  /// );
  /// ```
  ///
  /// Alternatively, [GolubInstanceManager.removeWeakReference] can be used to
  /// release the associated Native object manually.
  final List<Object?> Function(
    ProxyApiTestClass golub_instance,
    List<Object?> aList,
  )
  flutterEchoList;

  /// Returns the passed list with ProxyApis, to test serialization and
  /// deserialization.
  ///
  /// For the associated Native object to be automatically garbage collected,
  /// it is required that the implementation of this `Function` doesn't have a
  /// strong reference to the encapsulating class instance. When this `Function`
  /// references a non-local variable, it is strongly recommended to access it
  /// with a `WeakReference`:
  ///
  /// ```dart
  /// final WeakReference weakMyVariable = WeakReference(myVariable);
  /// final ProxyApiTestClass instance = ProxyApiTestClass(
  ///  flutterEchoProxyApiList: (ProxyApiTestClass golub_instance, ...) {
  ///    print(weakMyVariable?.target);
  ///  },
  /// );
  /// ```
  ///
  /// Alternatively, [GolubInstanceManager.removeWeakReference] can be used to
  /// release the associated Native object manually.
  final List<ProxyApiTestClass?> Function(
    ProxyApiTestClass golub_instance,
    List<ProxyApiTestClass?> aList,
  )
  flutterEchoProxyApiList;

  /// Returns the passed map, to test serialization and deserialization.
  ///
  /// For the associated Native object to be automatically garbage collected,
  /// it is required that the implementation of this `Function` doesn't have a
  /// strong reference to the encapsulating class instance. When this `Function`
  /// references a non-local variable, it is strongly recommended to access it
  /// with a `WeakReference`:
  ///
  /// ```dart
  /// final WeakReference weakMyVariable = WeakReference(myVariable);
  /// final ProxyApiTestClass instance = ProxyApiTestClass(
  ///  flutterEchoMap: (ProxyApiTestClass golub_instance, ...) {
  ///    print(weakMyVariable?.target);
  ///  },
  /// );
  /// ```
  ///
  /// Alternatively, [GolubInstanceManager.removeWeakReference] can be used to
  /// release the associated Native object manually.
  final Map<String?, Object?> Function(
    ProxyApiTestClass golub_instance,
    Map<String?, Object?> aMap,
  )
  flutterEchoMap;

  /// Returns the passed map with ProxyApis, to test serialization and
  /// deserialization.
  ///
  /// For the associated Native object to be automatically garbage collected,
  /// it is required that the implementation of this `Function` doesn't have a
  /// strong reference to the encapsulating class instance. When this `Function`
  /// references a non-local variable, it is strongly recommended to access it
  /// with a `WeakReference`:
  ///
  /// ```dart
  /// final WeakReference weakMyVariable = WeakReference(myVariable);
  /// final ProxyApiTestClass instance = ProxyApiTestClass(
  ///  flutterEchoProxyApiMap: (ProxyApiTestClass golub_instance, ...) {
  ///    print(weakMyVariable?.target);
  ///  },
  /// );
  /// ```
  ///
  /// Alternatively, [GolubInstanceManager.removeWeakReference] can be used to
  /// release the associated Native object manually.
  final Map<String?, ProxyApiTestClass?> Function(
    ProxyApiTestClass golub_instance,
    Map<String?, ProxyApiTestClass?> aMap,
  )
  flutterEchoProxyApiMap;

  /// Returns the passed enum to test serialization and deserialization.
  ///
  /// For the associated Native object to be automatically garbage collected,
  /// it is required that the implementation of this `Function` doesn't have a
  /// strong reference to the encapsulating class instance. When this `Function`
  /// references a non-local variable, it is strongly recommended to access it
  /// with a `WeakReference`:
  ///
  /// ```dart
  /// final WeakReference weakMyVariable = WeakReference(myVariable);
  /// final ProxyApiTestClass instance = ProxyApiTestClass(
  ///  flutterEchoEnum: (ProxyApiTestClass golub_instance, ...) {
  ///    print(weakMyVariable?.target);
  ///  },
  /// );
  /// ```
  ///
  /// Alternatively, [GolubInstanceManager.removeWeakReference] can be used to
  /// release the associated Native object manually.
  final ProxyApiTestEnum Function(
    ProxyApiTestClass golub_instance,
    ProxyApiTestEnum anEnum,
  )
  flutterEchoEnum;

  /// Returns the passed ProxyApi to test serialization and deserialization.
  ///
  /// For the associated Native object to be automatically garbage collected,
  /// it is required that the implementation of this `Function` doesn't have a
  /// strong reference to the encapsulating class instance. When this `Function`
  /// references a non-local variable, it is strongly recommended to access it
  /// with a `WeakReference`:
  ///
  /// ```dart
  /// final WeakReference weakMyVariable = WeakReference(myVariable);
  /// final ProxyApiTestClass instance = ProxyApiTestClass(
  ///  flutterEchoProxyApi: (ProxyApiTestClass golub_instance, ...) {
  ///    print(weakMyVariable?.target);
  ///  },
  /// );
  /// ```
  ///
  /// Alternatively, [GolubInstanceManager.removeWeakReference] can be used to
  /// release the associated Native object manually.
  final ProxyApiSuperClass Function(
    ProxyApiTestClass golub_instance,
    ProxyApiSuperClass aProxyApi,
  )
  flutterEchoProxyApi;

  /// Returns the passed boolean, to test serialization and deserialization.
  ///
  /// For the associated Native object to be automatically garbage collected,
  /// it is required that the implementation of this `Function` doesn't have a
  /// strong reference to the encapsulating class instance. When this `Function`
  /// references a non-local variable, it is strongly recommended to access it
  /// with a `WeakReference`:
  ///
  /// ```dart
  /// final WeakReference weakMyVariable = WeakReference(myVariable);
  /// final ProxyApiTestClass instance = ProxyApiTestClass(
  ///  flutterEchoNullableBool: (ProxyApiTestClass golub_instance, ...) {
  ///    print(weakMyVariable?.target);
  ///  },
  /// );
  /// ```
  ///
  /// Alternatively, [GolubInstanceManager.removeWeakReference] can be used to
  /// release the associated Native object manually.
  final bool? Function(
    ProxyApiTestClass golub_instance,
    bool? aBool,
  )?
  flutterEchoNullableBool;

  /// Returns the passed int, to test serialization and deserialization.
  ///
  /// For the associated Native object to be automatically garbage collected,
  /// it is required that the implementation of this `Function` doesn't have a
  /// strong reference to the encapsulating class instance. When this `Function`
  /// references a non-local variable, it is strongly recommended to access it
  /// with a `WeakReference`:
  ///
  /// ```dart
  /// final WeakReference weakMyVariable = WeakReference(myVariable);
  /// final ProxyApiTestClass instance = ProxyApiTestClass(
  ///  flutterEchoNullableInt: (ProxyApiTestClass golub_instance, ...) {
  ///    print(weakMyVariable?.target);
  ///  },
  /// );
  /// ```
  ///
  /// Alternatively, [GolubInstanceManager.removeWeakReference] can be used to
  /// release the associated Native object manually.
  final int? Function(
    ProxyApiTestClass golub_instance,
    int? anInt,
  )?
  flutterEchoNullableInt;

  /// Returns the passed double, to test serialization and deserialization.
  ///
  /// For the associated Native object to be automatically garbage collected,
  /// it is required that the implementation of this `Function` doesn't have a
  /// strong reference to the encapsulating class instance. When this `Function`
  /// references a non-local variable, it is strongly recommended to access it
  /// with a `WeakReference`:
  ///
  /// ```dart
  /// final WeakReference weakMyVariable = WeakReference(myVariable);
  /// final ProxyApiTestClass instance = ProxyApiTestClass(
  ///  flutterEchoNullableDouble: (ProxyApiTestClass golub_instance, ...) {
  ///    print(weakMyVariable?.target);
  ///  },
  /// );
  /// ```
  ///
  /// Alternatively, [GolubInstanceManager.removeWeakReference] can be used to
  /// release the associated Native object manually.
  final double? Function(
    ProxyApiTestClass golub_instance,
    double? aDouble,
  )?
  flutterEchoNullableDouble;

  /// Returns the passed string, to test serialization and deserialization.
  ///
  /// For the associated Native object to be automatically garbage collected,
  /// it is required that the implementation of this `Function` doesn't have a
  /// strong reference to the encapsulating class instance. When this `Function`
  /// references a non-local variable, it is strongly recommended to access it
  /// with a `WeakReference`:
  ///
  /// ```dart
  /// final WeakReference weakMyVariable = WeakReference(myVariable);
  /// final ProxyApiTestClass instance = ProxyApiTestClass(
  ///  flutterEchoNullableString: (ProxyApiTestClass golub_instance, ...) {
  ///    print(weakMyVariable?.target);
  ///  },
  /// );
  /// ```
  ///
  /// Alternatively, [GolubInstanceManager.removeWeakReference] can be used to
  /// release the associated Native object manually.
  final String? Function(
    ProxyApiTestClass golub_instance,
    String? aString,
  )?
  flutterEchoNullableString;

  /// Returns the passed byte list, to test serialization and deserialization.
  ///
  /// For the associated Native object to be automatically garbage collected,
  /// it is required that the implementation of this `Function` doesn't have a
  /// strong reference to the encapsulating class instance. When this `Function`
  /// references a non-local variable, it is strongly recommended to access it
  /// with a `WeakReference`:
  ///
  /// ```dart
  /// final WeakReference weakMyVariable = WeakReference(myVariable);
  /// final ProxyApiTestClass instance = ProxyApiTestClass(
  ///  flutterEchoNullableUint8List: (ProxyApiTestClass golub_instance, ...) {
  ///    print(weakMyVariable?.target);
  ///  },
  /// );
  /// ```
  ///
  /// Alternatively, [GolubInstanceManager.removeWeakReference] can be used to
  /// release the associated Native object manually.
  final Uint8List? Function(
    ProxyApiTestClass golub_instance,
    Uint8List? aList,
  )?
  flutterEchoNullableUint8List;

  /// Returns the passed list, to test serialization and deserialization.
  ///
  /// For the associated Native object to be automatically garbage collected,
  /// it is required that the implementation of this `Function` doesn't have a
  /// strong reference to the encapsulating class instance. When this `Function`
  /// references a non-local variable, it is strongly recommended to access it
  /// with a `WeakReference`:
  ///
  /// ```dart
  /// final WeakReference weakMyVariable = WeakReference(myVariable);
  /// final ProxyApiTestClass instance = ProxyApiTestClass(
  ///  flutterEchoNullableList: (ProxyApiTestClass golub_instance, ...) {
  ///    print(weakMyVariable?.target);
  ///  },
  /// );
  /// ```
  ///
  /// Alternatively, [GolubInstanceManager.removeWeakReference] can be used to
  /// release the associated Native object manually.
  final List<Object?>? Function(
    ProxyApiTestClass golub_instance,
    List<Object?>? aList,
  )?
  flutterEchoNullableList;

  /// Returns the passed map, to test serialization and deserialization.
  ///
  /// For the associated Native object to be automatically garbage collected,
  /// it is required that the implementation of this `Function` doesn't have a
  /// strong reference to the encapsulating class instance. When this `Function`
  /// references a non-local variable, it is strongly recommended to access it
  /// with a `WeakReference`:
  ///
  /// ```dart
  /// final WeakReference weakMyVariable = WeakReference(myVariable);
  /// final ProxyApiTestClass instance = ProxyApiTestClass(
  ///  flutterEchoNullableMap: (ProxyApiTestClass golub_instance, ...) {
  ///    print(weakMyVariable?.target);
  ///  },
  /// );
  /// ```
  ///
  /// Alternatively, [GolubInstanceManager.removeWeakReference] can be used to
  /// release the associated Native object manually.
  final Map<String?, Object?>? Function(
    ProxyApiTestClass golub_instance,
    Map<String?, Object?>? aMap,
  )?
  flutterEchoNullableMap;

  /// Returns the passed enum to test serialization and deserialization.
  ///
  /// For the associated Native object to be automatically garbage collected,
  /// it is required that the implementation of this `Function` doesn't have a
  /// strong reference to the encapsulating class instance. When this `Function`
  /// references a non-local variable, it is strongly recommended to access it
  /// with a `WeakReference`:
  ///
  /// ```dart
  /// final WeakReference weakMyVariable = WeakReference(myVariable);
  /// final ProxyApiTestClass instance = ProxyApiTestClass(
  ///  flutterEchoNullableEnum: (ProxyApiTestClass golub_instance, ...) {
  ///    print(weakMyVariable?.target);
  ///  },
  /// );
  /// ```
  ///
  /// Alternatively, [GolubInstanceManager.removeWeakReference] can be used to
  /// release the associated Native object manually.
  final ProxyApiTestEnum? Function(
    ProxyApiTestClass golub_instance,
    ProxyApiTestEnum? anEnum,
  )?
  flutterEchoNullableEnum;

  /// Returns the passed ProxyApi to test serialization and deserialization.
  ///
  /// For the associated Native object to be automatically garbage collected,
  /// it is required that the implementation of this `Function` doesn't have a
  /// strong reference to the encapsulating class instance. When this `Function`
  /// references a non-local variable, it is strongly recommended to access it
  /// with a `WeakReference`:
  ///
  /// ```dart
  /// final WeakReference weakMyVariable = WeakReference(myVariable);
  /// final ProxyApiTestClass instance = ProxyApiTestClass(
  ///  flutterEchoNullableProxyApi: (ProxyApiTestClass golub_instance, ...) {
  ///    print(weakMyVariable?.target);
  ///  },
  /// );
  /// ```
  ///
  /// Alternatively, [GolubInstanceManager.removeWeakReference] can be used to
  /// release the associated Native object manually.
  final ProxyApiSuperClass? Function(
    ProxyApiTestClass golub_instance,
    ProxyApiSuperClass? aProxyApi,
  )?
  flutterEchoNullableProxyApi;

  /// A no-op function taking no arguments and returning no value, to sanity
  /// test basic asynchronous calling.
  ///
  /// For the associated Native object to be automatically garbage collected,
  /// it is required that the implementation of this `Function` doesn't have a
  /// strong reference to the encapsulating class instance. When this `Function`
  /// references a non-local variable, it is strongly recommended to access it
  /// with a `WeakReference`:
  ///
  /// ```dart
  /// final WeakReference weakMyVariable = WeakReference(myVariable);
  /// final ProxyApiTestClass instance = ProxyApiTestClass(
  ///  flutterNoopAsync: (ProxyApiTestClass golub_instance, ...) {
  ///    print(weakMyVariable?.target);
  ///  },
  /// );
  /// ```
  ///
  /// Alternatively, [GolubInstanceManager.removeWeakReference] can be used to
  /// release the associated Native object manually.
  final Future<void> Function(ProxyApiTestClass golub_instance)?
  flutterNoopAsync;

  /// Returns the passed in generic Object asynchronously.
  ///
  /// For the associated Native object to be automatically garbage collected,
  /// it is required that the implementation of this `Function` doesn't have a
  /// strong reference to the encapsulating class instance. When this `Function`
  /// references a non-local variable, it is strongly recommended to access it
  /// with a `WeakReference`:
  ///
  /// ```dart
  /// final WeakReference weakMyVariable = WeakReference(myVariable);
  /// final ProxyApiTestClass instance = ProxyApiTestClass(
  ///  flutterEchoAsyncString: (ProxyApiTestClass golub_instance, ...) {
  ///    print(weakMyVariable?.target);
  ///  },
  /// );
  /// ```
  ///
  /// Alternatively, [GolubInstanceManager.removeWeakReference] can be used to
  /// release the associated Native object manually.
  final Future<String> Function(
    ProxyApiTestClass golub_instance,
    String aString,
  )
  flutterEchoAsyncString;

  @override
  final void Function(ProxyApiInterface golub_instance)? anInterfaceMethod;

  late final ProxyApiSuperClass attachedField = golubVar_attachedField();

  static final ProxyApiSuperClass _staticAttachedField =
      golubVar_staticAttachedField();

  static ProxyApiSuperClass get staticAttachedField =>
      GolubOverrides.proxyApiTestClass_staticAttachedField ??
      _staticAttachedField;

  static void golub_setUpMessageHandlers({
    bool golub_clearHandlers = false,
    BinaryMessenger? golub_binaryMessenger,
    GolubInstanceManager? golub_instanceManager,
    void Function(ProxyApiTestClass golub_instance)? flutterNoop,
    Object? Function(ProxyApiTestClass golub_instance)? flutterThrowError,
    void Function(ProxyApiTestClass golub_instance)? flutterThrowErrorFromVoid,
    bool Function(
      ProxyApiTestClass golub_instance,
      bool aBool,
    )?
    flutterEchoBool,
    int Function(
      ProxyApiTestClass golub_instance,
      int anInt,
    )?
    flutterEchoInt,
    double Function(
      ProxyApiTestClass golub_instance,
      double aDouble,
    )?
    flutterEchoDouble,
    String Function(
      ProxyApiTestClass golub_instance,
      String aString,
    )?
    flutterEchoString,
    Uint8List Function(
      ProxyApiTestClass golub_instance,
      Uint8List aList,
    )?
    flutterEchoUint8List,
    List<Object?> Function(
      ProxyApiTestClass golub_instance,
      List<Object?> aList,
    )?
    flutterEchoList,
    List<ProxyApiTestClass?> Function(
      ProxyApiTestClass golub_instance,
      List<ProxyApiTestClass?> aList,
    )?
    flutterEchoProxyApiList,
    Map<String?, Object?> Function(
      ProxyApiTestClass golub_instance,
      Map<String?, Object?> aMap,
    )?
    flutterEchoMap,
    Map<String?, ProxyApiTestClass?> Function(
      ProxyApiTestClass golub_instance,
      Map<String?, ProxyApiTestClass?> aMap,
    )?
    flutterEchoProxyApiMap,
    ProxyApiTestEnum Function(
      ProxyApiTestClass golub_instance,
      ProxyApiTestEnum anEnum,
    )?
    flutterEchoEnum,
    ProxyApiSuperClass Function(
      ProxyApiTestClass golub_instance,
      ProxyApiSuperClass aProxyApi,
    )?
    flutterEchoProxyApi,
    bool? Function(
      ProxyApiTestClass golub_instance,
      bool? aBool,
    )?
    flutterEchoNullableBool,
    int? Function(
      ProxyApiTestClass golub_instance,
      int? anInt,
    )?
    flutterEchoNullableInt,
    double? Function(
      ProxyApiTestClass golub_instance,
      double? aDouble,
    )?
    flutterEchoNullableDouble,
    String? Function(
      ProxyApiTestClass golub_instance,
      String? aString,
    )?
    flutterEchoNullableString,
    Uint8List? Function(
      ProxyApiTestClass golub_instance,
      Uint8List? aList,
    )?
    flutterEchoNullableUint8List,
    List<Object?>? Function(
      ProxyApiTestClass golub_instance,
      List<Object?>? aList,
    )?
    flutterEchoNullableList,
    Map<String?, Object?>? Function(
      ProxyApiTestClass golub_instance,
      Map<String?, Object?>? aMap,
    )?
    flutterEchoNullableMap,
    ProxyApiTestEnum? Function(
      ProxyApiTestClass golub_instance,
      ProxyApiTestEnum? anEnum,
    )?
    flutterEchoNullableEnum,
    ProxyApiSuperClass? Function(
      ProxyApiTestClass golub_instance,
      ProxyApiSuperClass? aProxyApi,
    )?
    flutterEchoNullableProxyApi,
    Future<void> Function(ProxyApiTestClass golub_instance)? flutterNoopAsync,
    Future<String> Function(
      ProxyApiTestClass golub_instance,
      String aString,
    )?
    flutterEchoAsyncString,
  }) {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _GolubInternalProxyApiBaseCodec(
          golub_instanceManager ?? GolubInstanceManager.instance,
        );
    final BinaryMessenger? binaryMessenger = golub_binaryMessenger;
    {
      final BasicMessageChannel<Object?>
      golubVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterNoop',
        golubChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (golub_clearHandlers) {
        golubVar_channel.setMessageHandler(null);
      } else {
        golubVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterNoop was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final ProxyApiTestClass? arg_golub_instance =
              (args[0] as ProxyApiTestClass?);
          assert(
            arg_golub_instance != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterNoop was null, expected non-null ProxyApiTestClass.',
          );
          try {
            (flutterNoop ?? arg_golub_instance!.flutterNoop)?.call(
              arg_golub_instance!,
            );
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }

    {
      final BasicMessageChannel<Object?>
      golubVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterThrowError',
        golubChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (golub_clearHandlers) {
        golubVar_channel.setMessageHandler(null);
      } else {
        golubVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterThrowError was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final ProxyApiTestClass? arg_golub_instance =
              (args[0] as ProxyApiTestClass?);
          assert(
            arg_golub_instance != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterThrowError was null, expected non-null ProxyApiTestClass.',
          );
          try {
            final Object? output = (flutterThrowError ??
                    arg_golub_instance!.flutterThrowError)
                ?.call(arg_golub_instance!);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }

    {
      final BasicMessageChannel<Object?>
      golubVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterThrowErrorFromVoid',
        golubChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (golub_clearHandlers) {
        golubVar_channel.setMessageHandler(null);
      } else {
        golubVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterThrowErrorFromVoid was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final ProxyApiTestClass? arg_golub_instance =
              (args[0] as ProxyApiTestClass?);
          assert(
            arg_golub_instance != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterThrowErrorFromVoid was null, expected non-null ProxyApiTestClass.',
          );
          try {
            (flutterThrowErrorFromVoid ??
                    arg_golub_instance!.flutterThrowErrorFromVoid)
                ?.call(arg_golub_instance!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }

    {
      final BasicMessageChannel<Object?>
      golubVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoBool',
        golubChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (golub_clearHandlers) {
        golubVar_channel.setMessageHandler(null);
      } else {
        golubVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoBool was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final ProxyApiTestClass? arg_golub_instance =
              (args[0] as ProxyApiTestClass?);
          assert(
            arg_golub_instance != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoBool was null, expected non-null ProxyApiTestClass.',
          );
          final bool? arg_aBool = (args[1] as bool?);
          assert(
            arg_aBool != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoBool was null, expected non-null bool.',
          );
          try {
            final bool output = (flutterEchoBool ??
                    arg_golub_instance!.flutterEchoBool)
                .call(arg_golub_instance!, arg_aBool!);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }

    {
      final BasicMessageChannel<Object?>
      golubVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoInt',
        golubChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (golub_clearHandlers) {
        golubVar_channel.setMessageHandler(null);
      } else {
        golubVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoInt was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final ProxyApiTestClass? arg_golub_instance =
              (args[0] as ProxyApiTestClass?);
          assert(
            arg_golub_instance != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoInt was null, expected non-null ProxyApiTestClass.',
          );
          final int? arg_anInt = (args[1] as int?);
          assert(
            arg_anInt != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoInt was null, expected non-null int.',
          );
          try {
            final int output = (flutterEchoInt ??
                    arg_golub_instance!.flutterEchoInt)
                .call(arg_golub_instance!, arg_anInt!);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }

    {
      final BasicMessageChannel<Object?>
      golubVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoDouble',
        golubChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (golub_clearHandlers) {
        golubVar_channel.setMessageHandler(null);
      } else {
        golubVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoDouble was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final ProxyApiTestClass? arg_golub_instance =
              (args[0] as ProxyApiTestClass?);
          assert(
            arg_golub_instance != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoDouble was null, expected non-null ProxyApiTestClass.',
          );
          final double? arg_aDouble = (args[1] as double?);
          assert(
            arg_aDouble != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoDouble was null, expected non-null double.',
          );
          try {
            final double output = (flutterEchoDouble ??
                    arg_golub_instance!.flutterEchoDouble)
                .call(arg_golub_instance!, arg_aDouble!);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }

    {
      final BasicMessageChannel<Object?>
      golubVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoString',
        golubChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (golub_clearHandlers) {
        golubVar_channel.setMessageHandler(null);
      } else {
        golubVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoString was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final ProxyApiTestClass? arg_golub_instance =
              (args[0] as ProxyApiTestClass?);
          assert(
            arg_golub_instance != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoString was null, expected non-null ProxyApiTestClass.',
          );
          final String? arg_aString = (args[1] as String?);
          assert(
            arg_aString != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoString was null, expected non-null String.',
          );
          try {
            final String output = (flutterEchoString ??
                    arg_golub_instance!.flutterEchoString)
                .call(arg_golub_instance!, arg_aString!);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }

    {
      final BasicMessageChannel<Object?>
      golubVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoUint8List',
        golubChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (golub_clearHandlers) {
        golubVar_channel.setMessageHandler(null);
      } else {
        golubVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoUint8List was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final ProxyApiTestClass? arg_golub_instance =
              (args[0] as ProxyApiTestClass?);
          assert(
            arg_golub_instance != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoUint8List was null, expected non-null ProxyApiTestClass.',
          );
          final Uint8List? arg_aList = (args[1] as Uint8List?);
          assert(
            arg_aList != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoUint8List was null, expected non-null Uint8List.',
          );
          try {
            final Uint8List output = (flutterEchoUint8List ??
                    arg_golub_instance!.flutterEchoUint8List)
                .call(arg_golub_instance!, arg_aList!);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }

    {
      final BasicMessageChannel<Object?>
      golubVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoList',
        golubChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (golub_clearHandlers) {
        golubVar_channel.setMessageHandler(null);
      } else {
        golubVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoList was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final ProxyApiTestClass? arg_golub_instance =
              (args[0] as ProxyApiTestClass?);
          assert(
            arg_golub_instance != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoList was null, expected non-null ProxyApiTestClass.',
          );
          final List<Object?>? arg_aList =
              (args[1] as List<Object?>?)?.cast<Object?>();
          assert(
            arg_aList != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoList was null, expected non-null List<Object?>.',
          );
          try {
            final List<Object?> output = (flutterEchoList ??
                    arg_golub_instance!.flutterEchoList)
                .call(arg_golub_instance!, arg_aList!);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }

    {
      final BasicMessageChannel<Object?>
      golubVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoProxyApiList',
        golubChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (golub_clearHandlers) {
        golubVar_channel.setMessageHandler(null);
      } else {
        golubVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoProxyApiList was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final ProxyApiTestClass? arg_golub_instance =
              (args[0] as ProxyApiTestClass?);
          assert(
            arg_golub_instance != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoProxyApiList was null, expected non-null ProxyApiTestClass.',
          );
          final List<ProxyApiTestClass?>? arg_aList =
              (args[1] as List<Object?>?)?.cast<ProxyApiTestClass?>();
          assert(
            arg_aList != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoProxyApiList was null, expected non-null List<ProxyApiTestClass?>.',
          );
          try {
            final List<ProxyApiTestClass?> output = (flutterEchoProxyApiList ??
                    arg_golub_instance!.flutterEchoProxyApiList)
                .call(arg_golub_instance!, arg_aList!);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }

    {
      final BasicMessageChannel<Object?>
      golubVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoMap',
        golubChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (golub_clearHandlers) {
        golubVar_channel.setMessageHandler(null);
      } else {
        golubVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoMap was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final ProxyApiTestClass? arg_golub_instance =
              (args[0] as ProxyApiTestClass?);
          assert(
            arg_golub_instance != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoMap was null, expected non-null ProxyApiTestClass.',
          );
          final Map<String?, Object?>? arg_aMap =
              (args[1] as Map<Object?, Object?>?)?.cast<String?, Object?>();
          assert(
            arg_aMap != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoMap was null, expected non-null Map<String?, Object?>.',
          );
          try {
            final Map<String?, Object?> output = (flutterEchoMap ??
                    arg_golub_instance!.flutterEchoMap)
                .call(arg_golub_instance!, arg_aMap!);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }

    {
      final BasicMessageChannel<Object?>
      golubVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoProxyApiMap',
        golubChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (golub_clearHandlers) {
        golubVar_channel.setMessageHandler(null);
      } else {
        golubVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoProxyApiMap was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final ProxyApiTestClass? arg_golub_instance =
              (args[0] as ProxyApiTestClass?);
          assert(
            arg_golub_instance != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoProxyApiMap was null, expected non-null ProxyApiTestClass.',
          );
          final Map<String?, ProxyApiTestClass?>? arg_aMap =
              (args[1] as Map<Object?, Object?>?)
                  ?.cast<String?, ProxyApiTestClass?>();
          assert(
            arg_aMap != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoProxyApiMap was null, expected non-null Map<String?, ProxyApiTestClass?>.',
          );
          try {
            final Map<String?, ProxyApiTestClass?> output =
                (flutterEchoProxyApiMap ??
                        arg_golub_instance!.flutterEchoProxyApiMap)
                    .call(arg_golub_instance!, arg_aMap!);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }

    {
      final BasicMessageChannel<Object?>
      golubVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoEnum',
        golubChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (golub_clearHandlers) {
        golubVar_channel.setMessageHandler(null);
      } else {
        golubVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoEnum was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final ProxyApiTestClass? arg_golub_instance =
              (args[0] as ProxyApiTestClass?);
          assert(
            arg_golub_instance != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoEnum was null, expected non-null ProxyApiTestClass.',
          );
          final ProxyApiTestEnum? arg_anEnum = (args[1] as ProxyApiTestEnum?);
          assert(
            arg_anEnum != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoEnum was null, expected non-null ProxyApiTestEnum.',
          );
          try {
            final ProxyApiTestEnum output = (flutterEchoEnum ??
                    arg_golub_instance!.flutterEchoEnum)
                .call(arg_golub_instance!, arg_anEnum!);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }

    {
      final BasicMessageChannel<Object?>
      golubVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoProxyApi',
        golubChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (golub_clearHandlers) {
        golubVar_channel.setMessageHandler(null);
      } else {
        golubVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoProxyApi was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final ProxyApiTestClass? arg_golub_instance =
              (args[0] as ProxyApiTestClass?);
          assert(
            arg_golub_instance != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoProxyApi was null, expected non-null ProxyApiTestClass.',
          );
          final ProxyApiSuperClass? arg_aProxyApi =
              (args[1] as ProxyApiSuperClass?);
          assert(
            arg_aProxyApi != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoProxyApi was null, expected non-null ProxyApiSuperClass.',
          );
          try {
            final ProxyApiSuperClass output = (flutterEchoProxyApi ??
                    arg_golub_instance!.flutterEchoProxyApi)
                .call(arg_golub_instance!, arg_aProxyApi!);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }

    {
      final BasicMessageChannel<Object?>
      golubVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableBool',
        golubChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (golub_clearHandlers) {
        golubVar_channel.setMessageHandler(null);
      } else {
        golubVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableBool was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final ProxyApiTestClass? arg_golub_instance =
              (args[0] as ProxyApiTestClass?);
          assert(
            arg_golub_instance != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableBool was null, expected non-null ProxyApiTestClass.',
          );
          final bool? arg_aBool = (args[1] as bool?);
          try {
            final bool? output = (flutterEchoNullableBool ??
                    arg_golub_instance!.flutterEchoNullableBool)
                ?.call(arg_golub_instance!, arg_aBool);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }

    {
      final BasicMessageChannel<Object?>
      golubVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableInt',
        golubChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (golub_clearHandlers) {
        golubVar_channel.setMessageHandler(null);
      } else {
        golubVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableInt was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final ProxyApiTestClass? arg_golub_instance =
              (args[0] as ProxyApiTestClass?);
          assert(
            arg_golub_instance != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableInt was null, expected non-null ProxyApiTestClass.',
          );
          final int? arg_anInt = (args[1] as int?);
          try {
            final int? output = (flutterEchoNullableInt ??
                    arg_golub_instance!.flutterEchoNullableInt)
                ?.call(arg_golub_instance!, arg_anInt);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }

    {
      final BasicMessageChannel<Object?>
      golubVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableDouble',
        golubChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (golub_clearHandlers) {
        golubVar_channel.setMessageHandler(null);
      } else {
        golubVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableDouble was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final ProxyApiTestClass? arg_golub_instance =
              (args[0] as ProxyApiTestClass?);
          assert(
            arg_golub_instance != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableDouble was null, expected non-null ProxyApiTestClass.',
          );
          final double? arg_aDouble = (args[1] as double?);
          try {
            final double? output = (flutterEchoNullableDouble ??
                    arg_golub_instance!.flutterEchoNullableDouble)
                ?.call(arg_golub_instance!, arg_aDouble);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }

    {
      final BasicMessageChannel<Object?>
      golubVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableString',
        golubChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (golub_clearHandlers) {
        golubVar_channel.setMessageHandler(null);
      } else {
        golubVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableString was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final ProxyApiTestClass? arg_golub_instance =
              (args[0] as ProxyApiTestClass?);
          assert(
            arg_golub_instance != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableString was null, expected non-null ProxyApiTestClass.',
          );
          final String? arg_aString = (args[1] as String?);
          try {
            final String? output = (flutterEchoNullableString ??
                    arg_golub_instance!.flutterEchoNullableString)
                ?.call(arg_golub_instance!, arg_aString);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }

    {
      final BasicMessageChannel<Object?>
      golubVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableUint8List',
        golubChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (golub_clearHandlers) {
        golubVar_channel.setMessageHandler(null);
      } else {
        golubVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableUint8List was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final ProxyApiTestClass? arg_golub_instance =
              (args[0] as ProxyApiTestClass?);
          assert(
            arg_golub_instance != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableUint8List was null, expected non-null ProxyApiTestClass.',
          );
          final Uint8List? arg_aList = (args[1] as Uint8List?);
          try {
            final Uint8List? output = (flutterEchoNullableUint8List ??
                    arg_golub_instance!.flutterEchoNullableUint8List)
                ?.call(arg_golub_instance!, arg_aList);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }

    {
      final BasicMessageChannel<Object?>
      golubVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableList',
        golubChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (golub_clearHandlers) {
        golubVar_channel.setMessageHandler(null);
      } else {
        golubVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableList was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final ProxyApiTestClass? arg_golub_instance =
              (args[0] as ProxyApiTestClass?);
          assert(
            arg_golub_instance != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableList was null, expected non-null ProxyApiTestClass.',
          );
          final List<Object?>? arg_aList =
              (args[1] as List<Object?>?)?.cast<Object?>();
          try {
            final List<Object?>? output = (flutterEchoNullableList ??
                    arg_golub_instance!.flutterEchoNullableList)
                ?.call(arg_golub_instance!, arg_aList);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }

    {
      final BasicMessageChannel<Object?>
      golubVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableMap',
        golubChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (golub_clearHandlers) {
        golubVar_channel.setMessageHandler(null);
      } else {
        golubVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableMap was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final ProxyApiTestClass? arg_golub_instance =
              (args[0] as ProxyApiTestClass?);
          assert(
            arg_golub_instance != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableMap was null, expected non-null ProxyApiTestClass.',
          );
          final Map<String?, Object?>? arg_aMap =
              (args[1] as Map<Object?, Object?>?)?.cast<String?, Object?>();
          try {
            final Map<String?, Object?>? output = (flutterEchoNullableMap ??
                    arg_golub_instance!.flutterEchoNullableMap)
                ?.call(arg_golub_instance!, arg_aMap);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }

    {
      final BasicMessageChannel<Object?>
      golubVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableEnum',
        golubChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (golub_clearHandlers) {
        golubVar_channel.setMessageHandler(null);
      } else {
        golubVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableEnum was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final ProxyApiTestClass? arg_golub_instance =
              (args[0] as ProxyApiTestClass?);
          assert(
            arg_golub_instance != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableEnum was null, expected non-null ProxyApiTestClass.',
          );
          final ProxyApiTestEnum? arg_anEnum = (args[1] as ProxyApiTestEnum?);
          try {
            final ProxyApiTestEnum? output = (flutterEchoNullableEnum ??
                    arg_golub_instance!.flutterEchoNullableEnum)
                ?.call(arg_golub_instance!, arg_anEnum);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }

    {
      final BasicMessageChannel<Object?>
      golubVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableProxyApi',
        golubChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (golub_clearHandlers) {
        golubVar_channel.setMessageHandler(null);
      } else {
        golubVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableProxyApi was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final ProxyApiTestClass? arg_golub_instance =
              (args[0] as ProxyApiTestClass?);
          assert(
            arg_golub_instance != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoNullableProxyApi was null, expected non-null ProxyApiTestClass.',
          );
          final ProxyApiSuperClass? arg_aProxyApi =
              (args[1] as ProxyApiSuperClass?);
          try {
            final ProxyApiSuperClass? output = (flutterEchoNullableProxyApi ??
                    arg_golub_instance!.flutterEchoNullableProxyApi)
                ?.call(arg_golub_instance!, arg_aProxyApi);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }

    {
      final BasicMessageChannel<Object?>
      golubVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterNoopAsync',
        golubChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (golub_clearHandlers) {
        golubVar_channel.setMessageHandler(null);
      } else {
        golubVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterNoopAsync was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final ProxyApiTestClass? arg_golub_instance =
              (args[0] as ProxyApiTestClass?);
          assert(
            arg_golub_instance != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterNoopAsync was null, expected non-null ProxyApiTestClass.',
          );
          try {
            await (flutterNoopAsync ?? arg_golub_instance!.flutterNoopAsync)
                ?.call(arg_golub_instance!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }

    {
      final BasicMessageChannel<Object?>
      golubVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoAsyncString',
        golubChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (golub_clearHandlers) {
        golubVar_channel.setMessageHandler(null);
      } else {
        golubVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoAsyncString was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final ProxyApiTestClass? arg_golub_instance =
              (args[0] as ProxyApiTestClass?);
          assert(
            arg_golub_instance != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoAsyncString was null, expected non-null ProxyApiTestClass.',
          );
          final String? arg_aString = (args[1] as String?);
          assert(
            arg_aString != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.flutterEchoAsyncString was null, expected non-null String.',
          );
          try {
            final String output = await (flutterEchoAsyncString ??
                    arg_golub_instance!.flutterEchoAsyncString)
                .call(arg_golub_instance!, arg_aString!);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
  }

  ProxyApiSuperClass golubVar_attachedField() {
    final ProxyApiSuperClass golubVar_instance =
        ProxyApiSuperClass.golub_detached(
          golub_binaryMessenger: golub_binaryMessenger,
          golub_instanceManager: golub_instanceManager,
        );
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    final int golubVar_instanceIdentifier = golub_instanceManager
        .addDartCreatedInstance(golubVar_instance);
    () async {
      const String golubVar_channelName =
          'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.attachedField';
      final BasicMessageChannel<Object?> golubVar_channel =
          BasicMessageChannel<Object?>(
            golubVar_channelName,
            golubChannelCodec,
            binaryMessenger: golubVar_binaryMessenger,
          );
      final Future<Object?> golubVar_sendFuture = golubVar_channel.send(
        <Object?>[this, golubVar_instanceIdentifier],
      );
      final List<Object?>? golubVar_replyList =
          await golubVar_sendFuture as List<Object?>?;
      if (golubVar_replyList == null) {
        throw _createConnectionError(golubVar_channelName);
      } else if (golubVar_replyList.length > 1) {
        throw PlatformException(
          code: golubVar_replyList[0]! as String,
          message: golubVar_replyList[1] as String?,
          details: golubVar_replyList[2],
        );
      } else {
        return;
      }
    }();
    return golubVar_instance;
  }

  static ProxyApiSuperClass golubVar_staticAttachedField() {
    final ProxyApiSuperClass golubVar_instance =
        ProxyApiSuperClass.golub_detached();
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _GolubInternalProxyApiBaseCodec(GolubInstanceManager.instance);
    final BinaryMessenger golubVar_binaryMessenger =
        ServicesBinding.instance.defaultBinaryMessenger;
    final int golubVar_instanceIdentifier = GolubInstanceManager.instance
        .addDartCreatedInstance(golubVar_instance);
    () async {
      const String golubVar_channelName =
          'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.staticAttachedField';
      final BasicMessageChannel<Object?> golubVar_channel =
          BasicMessageChannel<Object?>(
            golubVar_channelName,
            golubChannelCodec,
            binaryMessenger: golubVar_binaryMessenger,
          );
      final Future<Object?> golubVar_sendFuture = golubVar_channel.send(
        <Object?>[golubVar_instanceIdentifier],
      );
      final List<Object?>? golubVar_replyList =
          await golubVar_sendFuture as List<Object?>?;
      if (golubVar_replyList == null) {
        throw _createConnectionError(golubVar_channelName);
      } else if (golubVar_replyList.length > 1) {
        throw PlatformException(
          code: golubVar_replyList[0]! as String,
          message: golubVar_replyList[1] as String?,
          details: golubVar_replyList[2],
        );
      } else {
        return;
      }
    }();
    return golubVar_instance;
  }

  /// A no-op function taking no arguments and returning no value, to sanity
  /// test basic calling.
  Future<void> noop() async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.noop';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Returns an error, to test error handling.
  Future<Object?> throwError() async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.throwError';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return golubVar_replyList[0];
    }
  }

  /// Returns an error from a void function, to test error handling.
  Future<void> throwErrorFromVoid() async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.throwErrorFromVoid';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Returns a Flutter error, to test error handling.
  Future<Object?> throwFlutterError() async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.throwFlutterError';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return golubVar_replyList[0];
    }
  }

  /// Returns passed in int.
  Future<int> echoInt(int anInt) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoInt';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      anInt,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else if (golubVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubVar_replyList[0] as int?)!;
    }
  }

  /// Returns passed in double.
  Future<double> echoDouble(double aDouble) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoDouble';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aDouble,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else if (golubVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubVar_replyList[0] as double?)!;
    }
  }

  /// Returns the passed in boolean.
  Future<bool> echoBool(bool aBool) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoBool';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aBool,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else if (golubVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubVar_replyList[0] as bool?)!;
    }
  }

  /// Returns the passed in string.
  Future<String> echoString(String aString) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoString';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aString,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else if (golubVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubVar_replyList[0] as String?)!;
    }
  }

  /// Returns the passed in Uint8List.
  Future<Uint8List> echoUint8List(Uint8List aUint8List) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoUint8List';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aUint8List,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else if (golubVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubVar_replyList[0] as Uint8List?)!;
    }
  }

  /// Returns the passed in generic Object.
  Future<Object> echoObject(Object anObject) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoObject';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      anObject,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else if (golubVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return golubVar_replyList[0]!;
    }
  }

  /// Returns the passed list, to test serialization and deserialization.
  Future<List<Object?>> echoList(List<Object?> aList) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoList';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aList,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else if (golubVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubVar_replyList[0] as List<Object?>?)!.cast<Object?>();
    }
  }

  /// Returns the passed list with ProxyApis, to test serialization and
  /// deserialization.
  Future<List<ProxyApiTestClass>> echoProxyApiList(
    List<ProxyApiTestClass> aList,
  ) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoProxyApiList';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aList,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else if (golubVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubVar_replyList[0] as List<Object?>?)!
          .cast<ProxyApiTestClass>();
    }
  }

  /// Returns the passed map, to test serialization and deserialization.
  Future<Map<String?, Object?>> echoMap(Map<String?, Object?> aMap) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoMap';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aMap,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else if (golubVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubVar_replyList[0] as Map<Object?, Object?>?)!
          .cast<String?, Object?>();
    }
  }

  /// Returns the passed map with ProxyApis, to test serialization and
  /// deserialization.
  Future<Map<String, ProxyApiTestClass>> echoProxyApiMap(
    Map<String, ProxyApiTestClass> aMap,
  ) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoProxyApiMap';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aMap,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else if (golubVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubVar_replyList[0] as Map<Object?, Object?>?)!
          .cast<String, ProxyApiTestClass>();
    }
  }

  /// Returns the passed enum to test serialization and deserialization.
  Future<ProxyApiTestEnum> echoEnum(ProxyApiTestEnum anEnum) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoEnum';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      anEnum,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else if (golubVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubVar_replyList[0] as ProxyApiTestEnum?)!;
    }
  }

  /// Returns the passed ProxyApi to test serialization and deserialization.
  Future<ProxyApiSuperClass> echoProxyApi(ProxyApiSuperClass aProxyApi) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoProxyApi';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aProxyApi,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else if (golubVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubVar_replyList[0] as ProxyApiSuperClass?)!;
    }
  }

  /// Returns passed in int.
  Future<int?> echoNullableInt(int? aNullableInt) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoNullableInt';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aNullableInt,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return (golubVar_replyList[0] as int?);
    }
  }

  /// Returns passed in double.
  Future<double?> echoNullableDouble(double? aNullableDouble) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoNullableDouble';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aNullableDouble,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return (golubVar_replyList[0] as double?);
    }
  }

  /// Returns the passed in boolean.
  Future<bool?> echoNullableBool(bool? aNullableBool) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoNullableBool';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aNullableBool,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return (golubVar_replyList[0] as bool?);
    }
  }

  /// Returns the passed in string.
  Future<String?> echoNullableString(String? aNullableString) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoNullableString';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aNullableString,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return (golubVar_replyList[0] as String?);
    }
  }

  /// Returns the passed in Uint8List.
  Future<Uint8List?> echoNullableUint8List(
    Uint8List? aNullableUint8List,
  ) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoNullableUint8List';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aNullableUint8List,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return (golubVar_replyList[0] as Uint8List?);
    }
  }

  /// Returns the passed in generic Object.
  Future<Object?> echoNullableObject(Object? aNullableObject) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoNullableObject';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aNullableObject,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return golubVar_replyList[0];
    }
  }

  /// Returns the passed list, to test serialization and deserialization.
  Future<List<Object?>?> echoNullableList(List<Object?>? aNullableList) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoNullableList';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aNullableList,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return (golubVar_replyList[0] as List<Object?>?)?.cast<Object?>();
    }
  }

  /// Returns the passed map, to test serialization and deserialization.
  Future<Map<String?, Object?>?> echoNullableMap(
    Map<String?, Object?>? aNullableMap,
  ) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoNullableMap';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aNullableMap,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return (golubVar_replyList[0] as Map<Object?, Object?>?)
          ?.cast<String?, Object?>();
    }
  }

  Future<ProxyApiTestEnum?> echoNullableEnum(
    ProxyApiTestEnum? aNullableEnum,
  ) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoNullableEnum';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aNullableEnum,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return (golubVar_replyList[0] as ProxyApiTestEnum?);
    }
  }

  /// Returns the passed ProxyApi to test serialization and deserialization.
  Future<ProxyApiSuperClass?> echoNullableProxyApi(
    ProxyApiSuperClass? aNullableProxyApi,
  ) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoNullableProxyApi';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aNullableProxyApi,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return (golubVar_replyList[0] as ProxyApiSuperClass?);
    }
  }

  /// A no-op function taking no arguments and returning no value, to sanity
  /// test basic asynchronous calling.
  Future<void> noopAsync() async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.noopAsync';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Returns passed in int asynchronously.
  Future<int> echoAsyncInt(int anInt) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncInt';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      anInt,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else if (golubVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubVar_replyList[0] as int?)!;
    }
  }

  /// Returns passed in double asynchronously.
  Future<double> echoAsyncDouble(double aDouble) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncDouble';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aDouble,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else if (golubVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubVar_replyList[0] as double?)!;
    }
  }

  /// Returns the passed in boolean asynchronously.
  Future<bool> echoAsyncBool(bool aBool) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncBool';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aBool,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else if (golubVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubVar_replyList[0] as bool?)!;
    }
  }

  /// Returns the passed string asynchronously.
  Future<String> echoAsyncString(String aString) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncString';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aString,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else if (golubVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubVar_replyList[0] as String?)!;
    }
  }

  /// Returns the passed in Uint8List asynchronously.
  Future<Uint8List> echoAsyncUint8List(Uint8List aUint8List) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncUint8List';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aUint8List,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else if (golubVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubVar_replyList[0] as Uint8List?)!;
    }
  }

  /// Returns the passed in generic Object asynchronously.
  Future<Object> echoAsyncObject(Object anObject) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncObject';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      anObject,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else if (golubVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return golubVar_replyList[0]!;
    }
  }

  /// Returns the passed list, to test asynchronous serialization and deserialization.
  Future<List<Object?>> echoAsyncList(List<Object?> aList) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncList';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aList,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else if (golubVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubVar_replyList[0] as List<Object?>?)!.cast<Object?>();
    }
  }

  /// Returns the passed map, to test asynchronous serialization and deserialization.
  Future<Map<String?, Object?>> echoAsyncMap(Map<String?, Object?> aMap) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncMap';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aMap,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else if (golubVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubVar_replyList[0] as Map<Object?, Object?>?)!
          .cast<String?, Object?>();
    }
  }

  /// Returns the passed enum, to test asynchronous serialization and deserialization.
  Future<ProxyApiTestEnum> echoAsyncEnum(ProxyApiTestEnum anEnum) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncEnum';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      anEnum,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else if (golubVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubVar_replyList[0] as ProxyApiTestEnum?)!;
    }
  }

  /// Responds with an error from an async function returning a value.
  Future<Object?> throwAsyncError() async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.throwAsyncError';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return golubVar_replyList[0];
    }
  }

  /// Responds with an error from an async void function.
  Future<void> throwAsyncErrorFromVoid() async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.throwAsyncErrorFromVoid';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Responds with a Flutter error from an async function returning a value.
  Future<Object?> throwAsyncFlutterError() async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.throwAsyncFlutterError';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return golubVar_replyList[0];
    }
  }

  /// Returns passed in int asynchronously.
  Future<int?> echoAsyncNullableInt(int? anInt) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncNullableInt';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      anInt,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return (golubVar_replyList[0] as int?);
    }
  }

  /// Returns passed in double asynchronously.
  Future<double?> echoAsyncNullableDouble(double? aDouble) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncNullableDouble';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aDouble,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return (golubVar_replyList[0] as double?);
    }
  }

  /// Returns the passed in boolean asynchronously.
  Future<bool?> echoAsyncNullableBool(bool? aBool) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncNullableBool';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aBool,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return (golubVar_replyList[0] as bool?);
    }
  }

  /// Returns the passed string asynchronously.
  Future<String?> echoAsyncNullableString(String? aString) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncNullableString';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aString,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return (golubVar_replyList[0] as String?);
    }
  }

  /// Returns the passed in Uint8List asynchronously.
  Future<Uint8List?> echoAsyncNullableUint8List(Uint8List? aUint8List) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncNullableUint8List';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aUint8List,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return (golubVar_replyList[0] as Uint8List?);
    }
  }

  /// Returns the passed in generic Object asynchronously.
  Future<Object?> echoAsyncNullableObject(Object? anObject) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncNullableObject';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      anObject,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return golubVar_replyList[0];
    }
  }

  /// Returns the passed list, to test asynchronous serialization and deserialization.
  Future<List<Object?>?> echoAsyncNullableList(List<Object?>? aList) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncNullableList';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aList,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return (golubVar_replyList[0] as List<Object?>?)?.cast<Object?>();
    }
  }

  /// Returns the passed map, to test asynchronous serialization and deserialization.
  Future<Map<String?, Object?>?> echoAsyncNullableMap(
    Map<String?, Object?>? aMap,
  ) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncNullableMap';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aMap,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return (golubVar_replyList[0] as Map<Object?, Object?>?)
          ?.cast<String?, Object?>();
    }
  }

  /// Returns the passed enum, to test asynchronous serialization and deserialization.
  Future<ProxyApiTestEnum?> echoAsyncNullableEnum(
    ProxyApiTestEnum? anEnum,
  ) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoAsyncNullableEnum';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      anEnum,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return (golubVar_replyList[0] as ProxyApiTestEnum?);
    }
  }

  static Future<void> staticNoop({
    BinaryMessenger? golub_binaryMessenger,
    GolubInstanceManager? golub_instanceManager,
  }) async {
    if (GolubOverrides.proxyApiTestClass_staticNoop != null) {
      return GolubOverrides.proxyApiTestClass_staticNoop!();
    }
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _GolubInternalProxyApiBaseCodec(
          golub_instanceManager ?? GolubInstanceManager.instance,
        );
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.staticNoop';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(null);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return;
    }
  }

  static Future<String> echoStaticString(
    String aString, {
    BinaryMessenger? golub_binaryMessenger,
    GolubInstanceManager? golub_instanceManager,
  }) async {
    if (GolubOverrides.proxyApiTestClass_echoStaticString != null) {
      return GolubOverrides.proxyApiTestClass_echoStaticString!(aString);
    }
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _GolubInternalProxyApiBaseCodec(
          golub_instanceManager ?? GolubInstanceManager.instance,
        );
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.echoStaticString';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      aString,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else if (golubVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubVar_replyList[0] as String?)!;
    }
  }

  static Future<void> staticAsyncNoop({
    BinaryMessenger? golub_binaryMessenger,
    GolubInstanceManager? golub_instanceManager,
  }) async {
    if (GolubOverrides.proxyApiTestClass_staticAsyncNoop != null) {
      return GolubOverrides.proxyApiTestClass_staticAsyncNoop!();
    }
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _GolubInternalProxyApiBaseCodec(
          golub_instanceManager ?? GolubInstanceManager.instance,
        );
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.staticAsyncNoop';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(null);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> callFlutterNoop() async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterNoop';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<Object?> callFlutterThrowError() async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterThrowError';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return golubVar_replyList[0];
    }
  }

  Future<void> callFlutterThrowErrorFromVoid() async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterThrowErrorFromVoid';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<bool> callFlutterEchoBool(bool aBool) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoBool';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aBool,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else if (golubVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubVar_replyList[0] as bool?)!;
    }
  }

  Future<int> callFlutterEchoInt(int anInt) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoInt';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      anInt,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else if (golubVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubVar_replyList[0] as int?)!;
    }
  }

  Future<double> callFlutterEchoDouble(double aDouble) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoDouble';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aDouble,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else if (golubVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubVar_replyList[0] as double?)!;
    }
  }

  Future<String> callFlutterEchoString(String aString) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoString';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aString,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else if (golubVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubVar_replyList[0] as String?)!;
    }
  }

  Future<Uint8List> callFlutterEchoUint8List(Uint8List aUint8List) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoUint8List';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aUint8List,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else if (golubVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubVar_replyList[0] as Uint8List?)!;
    }
  }

  Future<List<Object?>> callFlutterEchoList(List<Object?> aList) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoList';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aList,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else if (golubVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubVar_replyList[0] as List<Object?>?)!.cast<Object?>();
    }
  }

  Future<List<ProxyApiTestClass?>> callFlutterEchoProxyApiList(
    List<ProxyApiTestClass?> aList,
  ) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoProxyApiList';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aList,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else if (golubVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubVar_replyList[0] as List<Object?>?)!
          .cast<ProxyApiTestClass?>();
    }
  }

  Future<Map<String?, Object?>> callFlutterEchoMap(
    Map<String?, Object?> aMap,
  ) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoMap';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aMap,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else if (golubVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubVar_replyList[0] as Map<Object?, Object?>?)!
          .cast<String?, Object?>();
    }
  }

  Future<Map<String?, ProxyApiTestClass?>> callFlutterEchoProxyApiMap(
    Map<String?, ProxyApiTestClass?> aMap,
  ) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoProxyApiMap';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aMap,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else if (golubVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubVar_replyList[0] as Map<Object?, Object?>?)!
          .cast<String?, ProxyApiTestClass?>();
    }
  }

  Future<ProxyApiTestEnum> callFlutterEchoEnum(ProxyApiTestEnum anEnum) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoEnum';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      anEnum,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else if (golubVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubVar_replyList[0] as ProxyApiTestEnum?)!;
    }
  }

  Future<ProxyApiSuperClass> callFlutterEchoProxyApi(
    ProxyApiSuperClass aProxyApi,
  ) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoProxyApi';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aProxyApi,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else if (golubVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubVar_replyList[0] as ProxyApiSuperClass?)!;
    }
  }

  Future<bool?> callFlutterEchoNullableBool(bool? aBool) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoNullableBool';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aBool,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return (golubVar_replyList[0] as bool?);
    }
  }

  Future<int?> callFlutterEchoNullableInt(int? anInt) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoNullableInt';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      anInt,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return (golubVar_replyList[0] as int?);
    }
  }

  Future<double?> callFlutterEchoNullableDouble(double? aDouble) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoNullableDouble';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aDouble,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return (golubVar_replyList[0] as double?);
    }
  }

  Future<String?> callFlutterEchoNullableString(String? aString) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoNullableString';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aString,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return (golubVar_replyList[0] as String?);
    }
  }

  Future<Uint8List?> callFlutterEchoNullableUint8List(
    Uint8List? aUint8List,
  ) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoNullableUint8List';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aUint8List,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return (golubVar_replyList[0] as Uint8List?);
    }
  }

  Future<List<Object?>?> callFlutterEchoNullableList(
    List<Object?>? aList,
  ) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoNullableList';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aList,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return (golubVar_replyList[0] as List<Object?>?)?.cast<Object?>();
    }
  }

  Future<Map<String?, Object?>?> callFlutterEchoNullableMap(
    Map<String?, Object?>? aMap,
  ) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoNullableMap';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aMap,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return (golubVar_replyList[0] as Map<Object?, Object?>?)
          ?.cast<String?, Object?>();
    }
  }

  Future<ProxyApiTestEnum?> callFlutterEchoNullableEnum(
    ProxyApiTestEnum? anEnum,
  ) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoNullableEnum';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      anEnum,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return (golubVar_replyList[0] as ProxyApiTestEnum?);
    }
  }

  Future<ProxyApiSuperClass?> callFlutterEchoNullableProxyApi(
    ProxyApiSuperClass? aProxyApi,
  ) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoNullableProxyApi';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aProxyApi,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return (golubVar_replyList[0] as ProxyApiSuperClass?);
    }
  }

  Future<void> callFlutterNoopAsync() async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterNoopAsync';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<String> callFlutterEchoAsyncString(String aString) async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiTestClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiTestClass.callFlutterEchoAsyncString';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
      aString,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else if (golubVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (golubVar_replyList[0] as String?)!;
    }
  }

  @override
  ProxyApiTestClass golub_copy() {
    return ProxyApiTestClass.golub_detached(
      golub_binaryMessenger: golub_binaryMessenger,
      golub_instanceManager: golub_instanceManager,
      aBool: aBool,
      anInt: anInt,
      aDouble: aDouble,
      aString: aString,
      aUint8List: aUint8List,
      aList: aList,
      aMap: aMap,
      anEnum: anEnum,
      aProxyApi: aProxyApi,
      aNullableBool: aNullableBool,
      aNullableInt: aNullableInt,
      aNullableDouble: aNullableDouble,
      aNullableString: aNullableString,
      aNullableUint8List: aNullableUint8List,
      aNullableList: aNullableList,
      aNullableMap: aNullableMap,
      aNullableEnum: aNullableEnum,
      aNullableProxyApi: aNullableProxyApi,
      anInterfaceMethod: anInterfaceMethod,
      flutterNoop: flutterNoop,
      flutterThrowError: flutterThrowError,
      flutterThrowErrorFromVoid: flutterThrowErrorFromVoid,
      flutterEchoBool: flutterEchoBool,
      flutterEchoInt: flutterEchoInt,
      flutterEchoDouble: flutterEchoDouble,
      flutterEchoString: flutterEchoString,
      flutterEchoUint8List: flutterEchoUint8List,
      flutterEchoList: flutterEchoList,
      flutterEchoProxyApiList: flutterEchoProxyApiList,
      flutterEchoMap: flutterEchoMap,
      flutterEchoProxyApiMap: flutterEchoProxyApiMap,
      flutterEchoEnum: flutterEchoEnum,
      flutterEchoProxyApi: flutterEchoProxyApi,
      flutterEchoNullableBool: flutterEchoNullableBool,
      flutterEchoNullableInt: flutterEchoNullableInt,
      flutterEchoNullableDouble: flutterEchoNullableDouble,
      flutterEchoNullableString: flutterEchoNullableString,
      flutterEchoNullableUint8List: flutterEchoNullableUint8List,
      flutterEchoNullableList: flutterEchoNullableList,
      flutterEchoNullableMap: flutterEchoNullableMap,
      flutterEchoNullableEnum: flutterEchoNullableEnum,
      flutterEchoNullableProxyApi: flutterEchoNullableProxyApi,
      flutterNoopAsync: flutterNoopAsync,
      flutterEchoAsyncString: flutterEchoAsyncString,
    );
  }
}

/// ProxyApi to serve as a super class to the core ProxyApi class.
class ProxyApiSuperClass extends GolubInternalProxyApiBaseClass {
  factory ProxyApiSuperClass({
    BinaryMessenger? golub_binaryMessenger,
    GolubInstanceManager? golub_instanceManager,
  }) {
    if (GolubOverrides.proxyApiSuperClass_new != null) {
      return GolubOverrides.proxyApiSuperClass_new!();
    }
    return ProxyApiSuperClass.golub_new(
      golub_binaryMessenger: golub_binaryMessenger,
      golub_instanceManager: golub_instanceManager,
    );
  }

  @protected
  ProxyApiSuperClass.golub_new({
    super.golub_binaryMessenger,
    super.golub_instanceManager,
  }) {
    final int golubVar_instanceIdentifier = golub_instanceManager
        .addDartCreatedInstance(this);
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiSuperClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiSuperClass.golub_defaultConstructor';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      golubVar_instanceIdentifier,
    ]);
    () async {
      final List<Object?>? golubVar_replyList =
          await golubVar_sendFuture as List<Object?>?;
      if (golubVar_replyList == null) {
        throw _createConnectionError(golubVar_channelName);
      } else if (golubVar_replyList.length > 1) {
        throw PlatformException(
          code: golubVar_replyList[0]! as String,
          message: golubVar_replyList[1] as String?,
          details: golubVar_replyList[2],
        );
      } else {
        return;
      }
    }();
  }

  /// Constructs [ProxyApiSuperClass] without creating the associated native object.
  ///
  /// This should only be used by subclasses created by this library or to
  /// create copies for an [GolubInstanceManager].
  @protected
  ProxyApiSuperClass.golub_detached({
    super.golub_binaryMessenger,
    super.golub_instanceManager,
  });

  late final _GolubInternalProxyApiBaseCodec _golubVar_codecProxyApiSuperClass =
      _GolubInternalProxyApiBaseCodec(golub_instanceManager);

  static void golub_setUpMessageHandlers({
    bool golub_clearHandlers = false,
    BinaryMessenger? golub_binaryMessenger,
    GolubInstanceManager? golub_instanceManager,
    ProxyApiSuperClass Function()? golub_newInstance,
  }) {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _GolubInternalProxyApiBaseCodec(
          golub_instanceManager ?? GolubInstanceManager.instance,
        );
    final BinaryMessenger? binaryMessenger = golub_binaryMessenger;
    {
      final BasicMessageChannel<Object?>
      golubVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golub.golub_integration_tests.ProxyApiSuperClass.golub_newInstance',
        golubChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (golub_clearHandlers) {
        golubVar_channel.setMessageHandler(null);
      } else {
        golubVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiSuperClass.golub_newInstance was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final int? arg_golub_instanceIdentifier = (args[0] as int?);
          assert(
            arg_golub_instanceIdentifier != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiSuperClass.golub_newInstance was null, expected non-null int.',
          );
          try {
            (golub_instanceManager ?? GolubInstanceManager.instance)
                .addHostCreatedInstance(
                  golub_newInstance?.call() ??
                      ProxyApiSuperClass.golub_detached(
                        golub_binaryMessenger: golub_binaryMessenger,
                        golub_instanceManager: golub_instanceManager,
                      ),
                  arg_golub_instanceIdentifier!,
                );
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
  }

  Future<void> aSuperMethod() async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecProxyApiSuperClass;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ProxyApiSuperClass.aSuperMethod';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return;
    }
  }

  @override
  ProxyApiSuperClass golub_copy() {
    return ProxyApiSuperClass.golub_detached(
      golub_binaryMessenger: golub_binaryMessenger,
      golub_instanceManager: golub_instanceManager,
    );
  }
}

/// ProxyApi to serve as an interface to the core ProxyApi class.
class ProxyApiInterface extends GolubInternalProxyApiBaseClass {
  /// Constructs [ProxyApiInterface] without creating the associated native object.
  ///
  /// This should only be used by subclasses created by this library or to
  /// create copies for an [GolubInstanceManager].
  @protected
  ProxyApiInterface.golub_detached({
    super.golub_binaryMessenger,
    super.golub_instanceManager,
    this.anInterfaceMethod,
  });

  /// Callback method.
  ///
  /// For the associated Native object to be automatically garbage collected,
  /// it is required that the implementation of this `Function` doesn't have a
  /// strong reference to the encapsulating class instance. When this `Function`
  /// references a non-local variable, it is strongly recommended to access it
  /// with a `WeakReference`:
  ///
  /// ```dart
  /// final WeakReference weakMyVariable = WeakReference(myVariable);
  /// final ProxyApiInterface instance = ProxyApiInterface(
  ///  anInterfaceMethod: (ProxyApiInterface golub_instance, ...) {
  ///    print(weakMyVariable?.target);
  ///  },
  /// );
  /// ```
  ///
  /// Alternatively, [GolubInstanceManager.removeWeakReference] can be used to
  /// release the associated Native object manually.
  final void Function(ProxyApiInterface golub_instance)? anInterfaceMethod;

  static void golub_setUpMessageHandlers({
    bool golub_clearHandlers = false,
    BinaryMessenger? golub_binaryMessenger,
    GolubInstanceManager? golub_instanceManager,
    ProxyApiInterface Function()? golub_newInstance,
    void Function(ProxyApiInterface golub_instance)? anInterfaceMethod,
  }) {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _GolubInternalProxyApiBaseCodec(
          golub_instanceManager ?? GolubInstanceManager.instance,
        );
    final BinaryMessenger? binaryMessenger = golub_binaryMessenger;
    {
      final BasicMessageChannel<Object?>
      golubVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golub.golub_integration_tests.ProxyApiInterface.golub_newInstance',
        golubChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (golub_clearHandlers) {
        golubVar_channel.setMessageHandler(null);
      } else {
        golubVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiInterface.golub_newInstance was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final int? arg_golub_instanceIdentifier = (args[0] as int?);
          assert(
            arg_golub_instanceIdentifier != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiInterface.golub_newInstance was null, expected non-null int.',
          );
          try {
            (golub_instanceManager ?? GolubInstanceManager.instance)
                .addHostCreatedInstance(
                  golub_newInstance?.call() ??
                      ProxyApiInterface.golub_detached(
                        golub_binaryMessenger: golub_binaryMessenger,
                        golub_instanceManager: golub_instanceManager,
                      ),
                  arg_golub_instanceIdentifier!,
                );
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }

    {
      final BasicMessageChannel<Object?>
      golubVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golub.golub_integration_tests.ProxyApiInterface.anInterfaceMethod',
        golubChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (golub_clearHandlers) {
        golubVar_channel.setMessageHandler(null);
      } else {
        golubVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiInterface.anInterfaceMethod was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final ProxyApiInterface? arg_golub_instance =
              (args[0] as ProxyApiInterface?);
          assert(
            arg_golub_instance != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ProxyApiInterface.anInterfaceMethod was null, expected non-null ProxyApiInterface.',
          );
          try {
            (anInterfaceMethod ?? arg_golub_instance!.anInterfaceMethod)?.call(
              arg_golub_instance!,
            );
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
  }

  @override
  ProxyApiInterface golub_copy() {
    return ProxyApiInterface.golub_detached(
      golub_binaryMessenger: golub_binaryMessenger,
      golub_instanceManager: golub_instanceManager,
      anInterfaceMethod: anInterfaceMethod,
    );
  }
}

class ClassWithApiRequirement extends GolubInternalProxyApiBaseClass {
  factory ClassWithApiRequirement({
    BinaryMessenger? golub_binaryMessenger,
    GolubInstanceManager? golub_instanceManager,
  }) {
    if (GolubOverrides.classWithApiRequirement_new != null) {
      return GolubOverrides.classWithApiRequirement_new!();
    }
    return ClassWithApiRequirement.golub_new(
      golub_binaryMessenger: golub_binaryMessenger,
      golub_instanceManager: golub_instanceManager,
    );
  }

  @protected
  ClassWithApiRequirement.golub_new({
    super.golub_binaryMessenger,
    super.golub_instanceManager,
  }) {
    final int golubVar_instanceIdentifier = golub_instanceManager
        .addDartCreatedInstance(this);
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecClassWithApiRequirement;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ClassWithApiRequirement.golub_defaultConstructor';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      golubVar_instanceIdentifier,
    ]);
    () async {
      final List<Object?>? golubVar_replyList =
          await golubVar_sendFuture as List<Object?>?;
      if (golubVar_replyList == null) {
        throw _createConnectionError(golubVar_channelName);
      } else if (golubVar_replyList.length > 1) {
        throw PlatformException(
          code: golubVar_replyList[0]! as String,
          message: golubVar_replyList[1] as String?,
          details: golubVar_replyList[2],
        );
      } else {
        return;
      }
    }();
  }

  /// Constructs [ClassWithApiRequirement] without creating the associated native object.
  ///
  /// This should only be used by subclasses created by this library or to
  /// create copies for an [GolubInstanceManager].
  @protected
  ClassWithApiRequirement.golub_detached({
    super.golub_binaryMessenger,
    super.golub_instanceManager,
  });

  late final _GolubInternalProxyApiBaseCodec
  _golubVar_codecClassWithApiRequirement = _GolubInternalProxyApiBaseCodec(
    golub_instanceManager,
  );

  static void golub_setUpMessageHandlers({
    bool golub_clearHandlers = false,
    BinaryMessenger? golub_binaryMessenger,
    GolubInstanceManager? golub_instanceManager,
    ClassWithApiRequirement Function()? golub_newInstance,
  }) {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _GolubInternalProxyApiBaseCodec(
          golub_instanceManager ?? GolubInstanceManager.instance,
        );
    final BinaryMessenger? binaryMessenger = golub_binaryMessenger;
    {
      final BasicMessageChannel<Object?>
      golubVar_channel = BasicMessageChannel<Object?>(
        'dev.bayori.golub.golub_integration_tests.ClassWithApiRequirement.golub_newInstance',
        golubChannelCodec,
        binaryMessenger: binaryMessenger,
      );
      if (golub_clearHandlers) {
        golubVar_channel.setMessageHandler(null);
      } else {
        golubVar_channel.setMessageHandler((Object? message) async {
          assert(
            message != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ClassWithApiRequirement.golub_newInstance was null.',
          );
          final List<Object?> args = (message as List<Object?>?)!;
          final int? arg_golub_instanceIdentifier = (args[0] as int?);
          assert(
            arg_golub_instanceIdentifier != null,
            'Argument for dev.bayori.golub.golub_integration_tests.ClassWithApiRequirement.golub_newInstance was null, expected non-null int.',
          );
          try {
            (golub_instanceManager ?? GolubInstanceManager.instance)
                .addHostCreatedInstance(
                  golub_newInstance?.call() ??
                      ClassWithApiRequirement.golub_detached(
                        golub_binaryMessenger: golub_binaryMessenger,
                        golub_instanceManager: golub_instanceManager,
                      ),
                  arg_golub_instanceIdentifier!,
                );
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
              error: PlatformException(code: 'error', message: e.toString()),
            );
          }
        });
      }
    }
  }

  Future<void> aMethod() async {
    final _GolubInternalProxyApiBaseCodec golubChannelCodec =
        _golubVar_codecClassWithApiRequirement;
    final BinaryMessenger? golubVar_binaryMessenger = golub_binaryMessenger;
    const String golubVar_channelName =
        'dev.bayori.golub.golub_integration_tests.ClassWithApiRequirement.aMethod';
    final BasicMessageChannel<Object?> golubVar_channel =
        BasicMessageChannel<Object?>(
          golubVar_channelName,
          golubChannelCodec,
          binaryMessenger: golubVar_binaryMessenger,
        );
    final Future<Object?> golubVar_sendFuture = golubVar_channel.send(<Object?>[
      this,
    ]);
    final List<Object?>? golubVar_replyList =
        await golubVar_sendFuture as List<Object?>?;
    if (golubVar_replyList == null) {
      throw _createConnectionError(golubVar_channelName);
    } else if (golubVar_replyList.length > 1) {
      throw PlatformException(
        code: golubVar_replyList[0]! as String,
        message: golubVar_replyList[1] as String?,
        details: golubVar_replyList[2],
      );
    } else {
      return;
    }
  }

  @override
  ClassWithApiRequirement golub_copy() {
    return ClassWithApiRequirement.golub_detached(
      golub_binaryMessenger: golub_binaryMessenger,
      golub_instanceManager: golub_instanceManager,
    );
  }
}
